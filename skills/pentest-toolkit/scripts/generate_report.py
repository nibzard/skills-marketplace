#!/usr/bin/env python3
"""
Security Report Generator
Generates comprehensive penetration testing reports from scan results
"""

import sys
import json
import time
import os
from datetime import datetime
from pathlib import Path

class ReportGenerator:
    def __init__(self, results_file=None):
        self.results_file = results_file
        self.results = {}
        self.findings = []
        self.load_results()

    def load_results(self):
        """Load results from JSON files"""
        # Look for result files in current directory
        result_files = [
            'sql_injection_results.json',
            'xss_results.json',
            'discovered_endpoints.json',
            'port_scan_results.json'
        ]

        if self.results_file:
            result_files = [self.results_file]

        for file in result_files:
            if os.path.exists(file):
                try:
                    with open(file, 'r') as f:
                        data = json.load(f)
                        test_type = data.get('test_type', file.replace('_results.json', '').replace('_', ' ').title())
                        self.results[test_type] = data

                        # Collect vulnerabilities
                        if 'vulnerabilities' in data:
                            for vuln in data['vulnerabilities']:
                                vuln['test_type'] = test_type
                                self.findings.append(vuln)
                except Exception as e:
                    print(f"[-] Error loading {file}: {e}")

    def calculate_severity_stats(self):
        """Calculate vulnerability statistics by severity"""
        stats = {
            'CRITICAL': 0,
            'HIGH': 0,
            'MEDIUM': 0,
            'LOW': 0,
            'INFO': 0
        }

        for finding in self.findings:
            severity = finding.get('severity', 'MEDIUM')
            stats[severity.upper()] = stats.get(severity.upper(), 0) + 1

        return stats

    def assess_risk(self, findings):
        """Assess overall risk level"""
        critical = len([f for f in findings if f.get('severity') == 'CRITICAL'])
        high = len([f for f in findings if f.get('severity') == 'HIGH'])

        if critical > 0:
            return 'CRITICAL', 'Immediate action required. Systems may be compromised.'
        elif high > 2:
            return 'HIGH', 'Significant risk. Urgent remediation recommended.'
        elif high > 0:
            return 'MEDIUM-HIGH', 'Moderate risk. Prompt remediation advised.'
        else:
            return 'LOW', 'Limited risk. Standard security practices recommended.'

    def generate_executive_summary(self):
        """Generate executive summary"""
        total_findings = len(self.findings)
        stats = self.calculate_severity_stats()
        risk_level, risk_assessment = self.assess_risk(self.findings)

        # Get target information
        target = 'Multiple targets'
        if self.results:
            first_result = list(self.results.values())[0]
            target = first_result.get('target', 'Unknown')

        summary = f"""
## Executive Summary

**Target:** {target}
**Assessment Date:** {datetime.now().strftime('%B %d, %Y')}
**Overall Risk Level:** {risk_level}

### Overview
A comprehensive security assessment was conducted on the target application/system.
The assessment identified {total_findings} security vulnerabilities across
{len(self.results)} test categories.

### Key Findings
- **Critical Vulnerabilities:** {stats['CRITICAL']}
- **High Severity:** {stats['HIGH']}
- **Medium Severity:** {stats['MEDIUM']}
- **Low Severity:** {stats['LOW']}

### Risk Assessment
{risk_assessment}

### Recommendations Priority
1. **Immediate:** Address all CRITICAL and HIGH severity vulnerabilities
2. **Short-term:** Remediate MEDIUM severity findings
3. **Ongoing:** Implement security best practices and regular testing
"""

        return summary

    def generate_technical_details(self):
        """Generate detailed technical findings"""
        if not self.findings:
            return "## Technical Details\n\nNo security vulnerabilities were detected during the assessment."

        # Group findings by type
        grouped_findings = {}
        for finding in self.findings:
            vuln_type = finding.get('type', 'Unknown')
            if vuln_type not in grouped_findings:
                grouped_findings[vuln_type] = []
            grouped_findings[vuln_type].append(finding)

        details = "## Technical Details\n\n"

        for vuln_type, findings in grouped_findings.items():
            details += f"### {vuln_type}\n\n"

            # Sort by severity
            severity_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3}
            findings.sort(key=lambda x: severity_order.get(x.get('severity', 'MEDIUM'), 2))

            for i, finding in enumerate(findings, 1):
                details += f"#### {i}. {finding.get('severity', 'MEDIUM')} Severity\n\n"

                # URL/Target
                if 'url' in finding:
                    details += f"**Location:** {finding['url']}\n\n"
                if 'parameter' in finding:
                    details += f"**Parameter:** {finding['parameter']}\n\n"
                if 'method' in finding:
                    details += f"**Method:** {finding['method']}\n\n"

                # Description
                details += "**Vulnerability Description:**\n"

                if finding.get('type') == 'SQL Injection':
                    details += "The application is vulnerable to SQL injection, allowing attackers to "
                    details += "execute arbitrary SQL commands that could lead to data theft, modification, "
                    details += "or complete database compromise.\n\n"
                elif finding.get('type') == 'Cross-Site Scripting':
                    details += "The application is vulnerable to cross-site scripting (XSS), allowing "
                    details += "attackers to inject malicious scripts that execute in victims' browsers, "
                    details += "potentially leading to session hijacking and data theft.\n\n"
                elif finding.get('type') == 'NoSQL Injection':
                    details += "The application is vulnerable to NoSQL injection, allowing attackers to "
                    details += "manipulate database queries and potentially bypass authentication or "
                    details += "access unauthorized data.\n\n"
                else:
                    details += f"A {finding.get('type', 'security')} vulnerability was identified "
                    details += "that could be exploited by attackers.\n\n"

                # Proof of Concept
                details += "**Proof of Concept:**\n"
                if 'payload' in finding:
                    details += f"```{finding['payload']}```\n\n"
                else:
                    details += "Vulnerability confirmed through automated testing.\n\n"

                # Impact
                details += "**Impact:**\n"
                if finding.get('severity') == 'CRITICAL':
                    details += "- Complete system compromise possible\n"
                    details += "- Data breach risk\n"
                    details += "- Service disruption\n"
                elif finding.get('severity') == 'HIGH':
                    details += "- Significant data exposure\n"
                    details += "- Privilege escalation possible\n"
                    details += "- Reputational damage\n"
                else:
                    details += "- Limited security impact\n"
                    details += "- Potential information disclosure\n"
                details += "\n"

                # Remediation
                details += "**Remediation:**\n"
                if finding.get('type') == 'SQL Injection':
                    details += "- Implement parameterized queries/prepared statements\n"
                    details += "- Use stored procedures where appropriate\n"
                    details += "- Apply input validation and output encoding\n"
                    details += "- Implement least privilege database access\n"
                elif finding.get('type') == 'Cross-Site Scripting':
                    details += "- Implement output encoding (HTML, JavaScript, URL)\n"
                    details += "- Use Content Security Policy (CSP) headers\n"
                    details += "- Validate and sanitize all user input\n"
                    details += "- Use secure frameworks that auto-escape content\n"
                elif finding.get('type') == 'NoSQL Injection':
                    details += "- Use type-safe query interfaces\n"
                    details += "- Implement input validation\n"
                    details += "- Avoid unsafe operators like $where\n"
                    details += "- Use object document mappers (ODMs)\n"
                else:
                    details += "- Review and fix the identified vulnerability\n"
                    details += "- Implement proper security controls\n"
                    details += "- Conduct regular security testing\n"
                details += "\n"

                details += "---\n\n"

        return details

    def generate_attack_surface(self):
        """Generate attack surface analysis"""
        attack_surface = "## Attack Surface Analysis\n\n"

        # Port findings
        if 'Port Scan' in self.results:
            port_data = self.results['Port Scan']
            open_ports = port_data.get('open_ports', [])

            attack_surface += f"### Network Services\n\n"
            attack_surface += f"**Open Ports:** {len(open_ports)}\n\n"

            if open_ports:
                attack_surface += "Discovered services:\n"
                for port_info in open_ports:
                    attack_surface += f"- Port {port_info['port']}/tcp: {port_info['service']}\n"
                attack_surface += "\n"

            # Risk assessment based on open ports
            risky_ports = [p for p in open_ports if p['port'] in [21, 23, 135, 139, 445, 3389, 5900]]
            if risky_ports:
                attack_surface += "**Risky Services Detected:**\n"
                for port in risky_ports:
                    attack_surface += f"- {port['service']} (Port {port['port']}) - Consider securing or disabling if not required\n"
                attack_surface += "\n"

        # Web endpoints
        if 'SQL Injection' in self.results or 'Cross Site Scripting' in self.results:
            attack_surface += "### Web Application\n\n"
            attack_surface += "Web application security testing identified:\n"

            if 'SQL Injection' in self.results:
                sql_data = self.results['SQL Injection']
                params_tested = sql_data.get('parameters_tested', [])
                attack_surface += f"- {len(params_tested)} parameters tested for SQL injection\n"

            if 'Cross Site Scripting' in self.results:
                xss_data = self.results['Cross Site Scripting']
                params_tested = xss_data.get('parameters_tested', [])
                attack_surface += f"- {len(params_tested)} parameters tested for XSS\n"

            attack_surface += "\n"

        # Discovered endpoints
        if 'Endpoint enumeration' in self.results:
            endpoint_data = self.results['Endpoint enumeration']
            endpoints = endpoint_data.get('endpoints', [])

            attack_surface += f"### Discovered Endpoints\n\n"
            attack_surface += f"Total endpoints discovered: {len(endpoints)}\n\n"

            # Categorize endpoints
            api_endpoints = [e for e in endpoints if '/api/' in e.lower()]
            admin_panels = [e for e in endpoints if any(p in e.lower() for p in ['admin', 'panel', 'dashboard'])]

            if api_endpoints:
                attack_surface += f"API Endpoints: {len(api_endpoints)}\n"
            if admin_panels:
                attack_surface += f"Admin Panels: {len(admin_panels)}\n"
            attack_surface += "\n"

        return attack_surface if len(attack_surface) > 40 else ""

    def generate_appendix(self):
        """Generate appendix with additional information"""
        appendix = "## Appendix\n\n"

        appendix += "### Test Methodology\n\n"
        appendix += "The security assessment was conducted using the following methodology:\n\n"
        appendix += "1. **Discovery Phase**\n"
        appendix += "   - Port scanning to identify open services\n"
        appendix += "   - Web application enumeration\n"
        appendix += "   - Endpoint discovery\n\n"
        appendix += "2. **Vulnerability Testing**\n"
        appendix += "   - Automated vulnerability scanning\n"
        appendix += "   - SQL injection testing\n"
        appendix += "   - Cross-site scripting detection\n"
        appendix += "   - Parameter manipulation testing\n\n"
        appendix += "3. **Analysis**\n"
        appendix += "   - Findings correlation\n"
        appendix += "   - Risk assessment\n"
        appendix += "   - Remediation recommendations\n\n"

        appendix += "### Testing Tools\n\n"
        appendix += "The following tools and techniques were used:\n"
        appendix += "- Custom Python security testing scripts\n"
        appendix += "- OWASP testing methodologies\n"
        appendix += "- Industry-standard vulnerability patterns\n\n"

        appendix += "### Severity Ratings\n\n"
        appendix += "- **CRITICAL**: Immediate threat, system compromise possible\n"
        appendix += "- **HIGH**: Significant risk, data exposure likely\n"
        appendix += "- **MEDIUM**: Moderate risk, limited impact\n"
        appendix += "- **LOW**: Minimal risk, minor security issue\n\n"

        return appendix

    def generate_markdown_report(self, output_file='security_report.md'):
        """Generate complete markdown report"""
        report = f"""# Security Assessment Report

{self.generate_executive_summary()}

{self.generate_attack_surface()}

{self.generate_technical_details()}

{self.generate_appendix()}

---
**Report Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**Assessment Tool:** AI-Powered Security Testing Toolkit
"""

        with open(output_file, 'w') as f:
            f.write(report)

        print(f"[+] Markdown report generated: {output_file}")
        return output_file

    def generate_json_report(self, output_file='security_report.json'):
        """Generate JSON report"""
        report_data = {
            'metadata': {
                'report_date': datetime.now().isoformat(),
                'tool': 'AI-Powered Security Testing Toolkit',
                'version': '1.0'
            },
            'summary': {
                'total_findings': len(self.findings),
                'severity_stats': self.calculate_severity_stats(),
                'risk_level': self.assess_risk(self.findings)[0],
                'tests_performed': list(self.results.keys())
            },
            'findings': self.findings,
            'raw_results': self.results
        }

        with open(output_file, 'w') as f:
            json.dump(report_data, f, indent=2)

        print(f"[+] JSON report generated: {output_file}")
        return output_file

def main():
    print("AI-Powered Security Testing Report Generator")
    print("=" * 50)

    # Check for results file argument
    results_file = None
    if len(sys.argv) > 1:
        results_file = sys.argv[1]

    # Generate report
    generator = ReportGenerator(results_file)

    if not generator.results:
        print("[-] No scan results found in current directory")
        print("    Run security scans first to generate results files")
        sys.exit(1)

    print(f"[*] Found results from {len(generator.results)} tests")
    print(f"[*] Total findings: {len(generator.findings)}")

    # Generate reports
    md_file = generator.generate_markdown_report()
    json_file = generator.generate_json_report()

    print("\n" + "=" * 50)
    print("[+] Report generation complete!")
    print(f"[+] Markdown: {md_file}")
    print(f"[+] JSON: {json_file}")

    # Show summary
    stats = generator.calculate_severity_stats()
    risk_level = generator.assess_risk(generator.findings)[0]
    print(f"\n[*] Summary: {len(generator.findings)} findings, Risk Level: {risk_level}")

if __name__ == "__main__":
    main()