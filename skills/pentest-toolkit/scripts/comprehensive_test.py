#!/usr/bin/env python3
"""
Comprehensive Security Testing Orchestrator
Coordinates multiple security tests for thorough assessment
"""

import sys
import json
import time
import os
import subprocess
import signal
from datetime import datetime

class SecurityTestOrchestrator:
    def __init__(self, target_url):
        self.target_url = target_url
        self.test_results = {}
        self.vulnerabilities = []
        self.start_time = None

    def __init__(self, target_url, use_uv=False):
        self.target_url = target_url
        self.test_results = {}
        self.vulnerabilities = []
        self.start_time = None
        self.use_uv = use_uv or self._check_uv_available()

    def _check_uv_available(self):
        """Check if uv is available for execution"""
        try:
            subprocess.run(['uv', '--version'], capture_output=True, check=True)
            return True
        except:
            return False

    def run_command(self, command, script_name):
        """Run a command using uv if available, otherwise python directly"""
        try:
            if self.use_uv:
                # Use uv run for isolated execution
                script_path = os.path.join(os.path.dirname(__file__), script_name)
                uv_command = ['uv', 'run', '--no-project', '--python', 'python3', script_path] + command[2:]
                print(f"[*] Executing with uv: {' '.join(uv_command)}")
                result = subprocess.run(uv_command, capture_output=True, text=True, timeout=300)
            else:
                # Fallback to direct python execution
                print(f"[*] Executing: {' '.join(command)}")
                result = subprocess.run(command, capture_output=True, text=True, timeout=300)
            return result.returncode == 0
        except subprocess.TimeoutExpired:
            print(f"[!] Command timed out: {' '.join(command)}")
            return False
        except Exception as e:
            print(f"[!] Error running command: {e}")
            return False

    def run_endpoint_enumeration(self):
        """Run endpoint enumeration"""
        print("\n" + "="*60)
        print("Phase 1: Endpoint Enumeration")
        print("="*60)

        script_path = os.path.join(os.path.dirname(__file__), 'enumerate_endpoints.py')
        if not os.path.exists(script_path):
            print("[-] Endpoint enumeration script not found")
            return False

        return self.run_command(['python3', script_path, self.target_url], 'enumerate_endpoints.py')

    def run_port_scan(self):
        """Run port scanning"""
        print("\n" + "="*60)
        print("Phase 2: Port Scanning")
        print("="*60)

        # Extract domain from URL for port scanning
        from urllib.parse import urlparse
        parsed = urlparse(self.target_url)
        host = parsed.netloc.split(':')[0]

        script_path = os.path.join(os.path.dirname(__file__), 'scan_ports.py')
        if not os.path.exists(script_path):
            print("[-] Port scanning script not found")
            return False

        return self.run_command(['python3', script_path, host], 'scan_ports.py')

    def run_vulnerability_tests(self):
        """Run vulnerability testing"""
        print("\n" + "="*60)
        print("Phase 3: Vulnerability Testing")
        print("="*60)

        scripts = [
            ('sql_injection.py', 'SQL Injection Testing'),
            ('test_xss.py', 'Cross-Site Scripting Testing'),
        ]

        success_count = 0
        for script, description in scripts:
            print(f"\n[*] Running: {description}")
            script_path = os.path.join(os.path.dirname(__file__), script)
            if os.path.exists(script_path):
                if self.run_command(['python3', script_path, self.target_url], script):
                    success_count += 1
            else:
                print(f"[-] Script not found: {script}")

        return success_count > 0

    def load_results(self):
        """Load all test results"""
        result_files = [
            'discovered_endpoints.json',
            'port_scan_results.json',
            'sql_injection_results.json',
            'xss_results.json'
        ]

        for file in result_files:
            if os.path.exists(file):
                try:
                    with open(file, 'r') as f:
                        data = json.load(f)
                        test_type = data.get('test_type', file.replace('_results.json', ''))
                        self.test_results[test_type] = data

                        # Collect vulnerabilities
                        if 'vulnerabilities' in data:
                            self.vulnerabilities.extend(data['vulnerabilities'])
                except Exception as e:
                    print(f"[-] Error loading {file}: {e}")

    def print_summary(self):
        """Print test summary"""
        duration = time.time() - self.start_time if self.start_time else 0

        print("\n" + "="*60)
        print("Security Assessment Summary")
        print("="*60)

        print(f"Target: {self.target_url}")
        print(f"Duration: {duration:.1f} seconds")
        print(f"Tests Completed: {len(self.test_results)}")
        print(f"Vulnerabilities Found: {len(self.vulnerabilities)}")

        if self.vulnerabilities:
            # Count by severity
            severity_counts = {}
            for vuln in self.vulnerabilities:
                sev = vuln.get('severity', 'MEDIUM')
                severity_counts[sev] = severity_counts.get(sev, 0) + 1

            print("\nVulnerability Breakdown:")
            for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
                count = severity_counts.get(severity, 0)
                if count > 0:
                    print(f"  {severity}: {count}")

            print("\nTop Findings:")
            # Show top 5 most critical findings
            sorted_vulns = sorted(self.vulnerabilities,
                                 key=lambda x: {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3}.get(x.get('severity', 3), 3))

            for i, vuln in enumerate(sorted_vulns[:5], 1):
                print(f"\n{i}. {vuln.get('type', 'Unknown')} - {vuln.get('severity', 'MEDIUM')}")
                print(f"   Location: {vuln.get('url', 'N/A')}")
                if vuln.get('parameter'):
                    print(f"   Parameter: {vuln['parameter']}")
                print(f"   Details: {vuln.get('reason', vuln.get('reflection', 'N/A'))}")
        else:
            print("\n[+] No security vulnerabilities detected!")

        print(f"\n[*] Detailed reports available in:")
        print(f"    - discovered_endpoints.json")
        print(f"    - port_scan_results.json")
        print(f"    - sql_injection_results.json")
        print(f"    - xss_results.json")

    def run_comprehensive_test(self):
        """Run all security tests"""
        print("AI-Powered Security Testing Toolkit")
        print("Comprehensive Security Assessment")
        print("="*60)
        print(f"Target: {self.target_url}")
        print(f"Started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print()

        self.start_time = time.time()

        # Phase 1: Discovery
        print("Starting Phase 1: Attack Surface Discovery...")
        if not self.run_endpoint_enumeration():
            print("[-] Endpoint enumeration failed")

        if not self.run_port_scan():
            print("[-] Port scanning failed")

        # Phase 2: Vulnerability Testing
        print("\nStarting Phase 2: Vulnerability Assessment...")
        if not self.run_vulnerability_tests():
            print("[-] Some vulnerability tests failed")

        # Load and analyze results
        print("\nLoading test results...")
        self.load_results()

        # Print summary
        self.print_summary()

        # Generate comprehensive report
        print("\nGenerating comprehensive report...")
        report_script = os.path.join(os.path.dirname(__file__), 'generate_report.py')
        if os.path.exists(report_script):
            self.run_command(['python3', report_script], 'generate_report.py')

        return len(self.vulnerabilities)

def signal_handler(sig, frame):
    """Handle Ctrl+C gracefully"""
    print("\n\n[!] Test interrupted by user")
    print("[!] Partial results may be available in JSON files")
    sys.exit(1)

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 comprehensive_test.py <target_url> [--uv]")
        print("Example: python3 comprehensive_test.py https://example.com")
        print("         python3 comprehensive_test.py https://example.com --uv")
        print("\nThis will run:")
        print("  1. Endpoint enumeration")
        print("  2. Port scanning")
        print("  3. SQL injection testing")
        print("  4. XSS testing")
        print("  5. Generate comprehensive report")
        sys.exit(1)

    # Register signal handler for graceful exit
    signal.signal(signal.SIGINT, signal_handler)

    target_url = sys.argv[1]
    use_uv = '--uv' in sys.argv

    # Validate URL
    if not (target_url.startswith('http://') or target_url.startswith('https://')):
        target_url = 'https://' + target_url

    # Check for required scripts
    required_scripts = ['enumerate_endpoints.py', 'scan_ports.py', 'test_sql_injection.py', 'test_xss.py']
    missing_scripts = []
    for script in required_scripts:
        if not os.path.exists(os.path.join(os.path.dirname(__file__), script)):
            missing_scripts.append(script)

    if missing_scripts:
        print(f"[-] Missing required scripts: {', '.join(missing_scripts)}")
        print("[-] Please ensure all scripts are in the same directory")
        sys.exit(1)

    # Run comprehensive test
    orchestrator = SecurityTestOrchestrator(target_url, use_uv=use_uv)

    try:
        vuln_count = orchestrator.run_comprehensive_test()

        # Exit code based on findings
        if vuln_count > 0:
            print(f"\n[!] Assessment complete: {vuln_count} vulnerabilities found")
            sys.exit(1)  # Exit with error code if vulnerabilities found
        else:
            print("\n[+] Assessment complete: No vulnerabilities detected")
            sys.exit(0)

    except Exception as e:
        print(f"\n[!] Error during assessment: {e}")
        sys.exit(2)

if __name__ == "__main__":
    main()