# Pentest-Toolkit Technical Reference

This document provides detailed technical reference for the AI-Powered Security Testing Toolkit, focusing on APIs, JSON schemas, and implementation details for advanced users and AI agents.

## Agent Tools API Reference

### 1. discover_structure.py

Discovers application structure, API endpoints, data models, and business logic patterns.

#### Usage
```bash
uv run python tools/discover_structure.py <target_url> [options]
```

#### Output JSON Schema
```json
{
  "base_url": "string",
  "discovered_endpoints": [
    {
      "url": "string",
      "method": ["GET", "POST", "PUT", "DELETE"],
      "status": "number",
      "content_type": "string",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "location": "query|body|header"
        }
      ]
    }
  ],
  "data_models": {
    "model_name": {
      "type": "object|array|string",
      "fields": {
        "field_name": {
          "type": "string|number|boolean|object",
          "format": "email|date|uuid|null",
          "constraints": {
            "required": "boolean",
            "min_length": "number",
            "max_length": "number"
          }
        }
      },
      "relationships": [
        {
          "field": "string",
          "pattern": "regex",
          "type": "one_to_many|many_to_one|many_to_many"
        }
      ]
    }
  },
  "business_entities": ["string"],
  "authentication_patterns": {
    "login_endpoints": ["string"],
    "token_based": "boolean",
    "session_based": "boolean",
    "oauth_provider": "string|null"
  },
  "technologies": ["string"],
  "vulnerability_indicators": [
    {
      "type": "string",
      "location": "string",
      "severity": "LOW|MEDIUM|HIGH|CRITICAL"
    }
  ]
}
```

### 2. analyze_responses.py

Analyzes HTTP responses to extract patterns, relationships, and security-relevant information.

#### Usage
```bash
uv run python tools/analyze_responses.py <responses_file.json>
```

#### Input Format
JSON file containing HTTP responses:
```json
{
  "responses": [
    {
      "url": "string",
      "method": "string",
      "status_code": "number",
      "headers": {},
      "body": "string",
      "timestamp": "string"
    }
  ]
}
```

#### Output JSON Schema
```json
{
  "patterns": {
    "data_relationships": [
      {
        "source_entity": "string",
        "target_entity": "string",
        "relationship_type": "string",
        "field_pattern": "regex",
        "examples": ["string"]
      }
    ],
    "business_logic_flaws": [
      {
        "pattern_name": "string",
        "description": "string",
        "affected_endpoints": ["string"],
        "risk_level": "LOW|MEDIUM|HIGH|CRITICAL",
        "test_indicators": ["string"]
      }
    ],
    "authentication_bypasses": [
      {
        "endpoint": "string",
        "bypass_method": "string",
        "success_indicators": ["string"]
      }
    ]
  },
  "recommendations": [
    {
      "category": "string",
      "priority": "number",
      "description": "string",
      "test_method": "string"
    }
  ]
}
```

### 3. generate_context_tests.py

Generates context-aware security tests based on discovered patterns and application structure.

#### Usage
```bash
uv run python tools/generate_context_tests.py <structure_file> <patterns_file>
```

#### Output JSON Schema
```json
{
  "test_scenarios": [
    {
      "id": "string",
      "name": "string",
      "description": "string",
      "category": "authorization|authentication|business_logic|injection",
      "risk_level": "LOW|MEDIUM|HIGH|CRITICAL",
      "target_endpoints": ["string"],
      "prerequisites": ["string"],
      "test_cases": [
        {
          "id": "string",
          "description": "string",
          "method": "string",
          "url": "string",
          "headers": {},
          "body": {},
          "expected_indicators": {
            "success": ["string"],
            "failure": ["string"]
          },
          "payloads": [
            {
              "description": "string",
              "value": {},
              "context": "string"
            }
          ]
        }
      ]
    }
  ],
  "metadata": {
    "generated_at": "string",
    "total_tests": "number",
    "risk_distribution": {
      "critical": "number",
      "high": "number",
      "medium": "number",
      "low": "number"
    }
  }
}
```

## Pattern Libraries

### Business Logic Patterns

Located at: `patterns/business_logic.json`

#### Structure
```json
{
  "pattern_categories": [
    {
      "name": "string",
      "description": "string",
      "patterns": [
        {
          "id": "string",
          "name": "string",
          "description": "string",
          "severity": "LOW|MEDIUM|HIGH|CRITICAL",
          "indicators": ["string"],
          "test_methods": [
            {
              "description": "string",
              "steps": ["string"],
              "payloads": [
                {
                  "field": "string",
                  "value": "string",
                  "context": "string"
                }
              ]
            }
          ],
          "mitigation": "string"
        }
      ]
    }
  ]
}
```

#### Pattern Categories

1. **Authorization Bypass**
   - IDOR (Insecure Direct Object Reference)
   - Privilege escalation
   - Role manipulation
   - Resource ownership bypass

2. **State Manipulation**
   - Checkout process abuse
   - Multi-step workflow bypass
   - State transition abuse
   - Race conditions

3. **Business Logic Flaws**
   - Price manipulation
   - Coupon abuse
   - Rate limit bypass
   - Functionality abuse

4. **Authentication Flaws**
   - Session fixation
   - Token manipulation
   - Password reset abuse
   - 2FA bypass

### Data Relationship Patterns

Located at: `patterns/data_relationships.json`

#### Structure
```json
{
  "relationship_patterns": [
    {
      "pattern": "regex",
      "type": "one_to_many|many_to_one|many_to_many|self_reference",
      "security_implications": [
        {
          "type": "string",
          "description": "string",
          "test_scenario": "string"
        }
      ],
      "common_fields": ["string"]
    }
  ]
}
```

## CLI Tools Reference

### Available Scripts

Located in: `scripts/`

1. **enumerate_endpoints.py**
   - Discovers URLs and API endpoints
   - Output: `discovered_endpoints.json`

2. **scan_ports.py**
   - Port scanning functionality
   - Output: `port_scan_results.json`

3. **test_sql_injection.py**
   - SQL injection testing
   - Output: `sql_injection_results.json`

4. **test_xss.py**
   - Cross-site scripting testing
   - Output: `xss_results.json`

5. **comprehensive_test.py**
   - Runs all security tests
   - Outputs: All above JSON files

6. **generate_report.py**
   - Generates markdown/HTML reports
   - Input: Any of the above JSON files
   - Output: `security_report.md`, `security_report.html`

## Execution Requirements

### Critical: UV Usage
All script executions MUST use `uv run python` for proper dependency management:

```bash
# Correct
uv run python scripts/discover_structure.py https://target.com

# Incorrect (will fail)
python scripts/discover_structure.py https://target.com
```

### Environment Setup

The CLI automatically handles uv installation:
```python
# From cli.py
def install_uv(self) -> bool:
    """Install uv if not available"""
    print("Installing uv (Python package manager)...")
    try:
        install_script = '''
        curl -LsSf https://astral.sh/uv/install.sh | sh
        '''
        result = subprocess.run(install_script, shell=True, capture_output=True)
        return result.returncode == 0
    except Exception as e:
        print(f"Failed to install uv: {e}")
        return False
```

## Output Formats

### Standard JSON Response Format

All tools follow this standard response structure:
```json
{
  "success": "boolean",
  "message": "string",
  "data": {},
  "errors": [],
  "metadata": {
    "timestamp": "string",
    "tool_version": "string",
    "execution_time": "number"
  }
}
```

### Error Handling

Tools return structured error information:
```json
{
  "success": false,
  "message": "Error description",
  "errors": [
    {
      "type": "NETWORK_ERROR|VALIDATION_ERROR|SECURITY_ERROR",
      "message": "Specific error message",
      "context": {}
    }
  ]
}
```

## Security Considerations

### Input Validation
- All URLs are validated before testing
- Payload parameters are sanitized
- Rate limiting is respected

### Output Sanitization
- Sensitive data is masked in outputs
- Credentials are never logged
- Private information is redacted

### Responsible Usage
All tools include responsible usage checks:
```python
def check_authorization(target_url):
    """Check if testing is authorized"""
    if is_public_target(target_url):
        return True
    if is_private_network(target_url):
        raise UnauthorizedError("Cannot test private networks without explicit authorization")
```

## Troubleshooting

### Common Issues

1. **UV Not Found**
   - Solution: The CLI will auto-install UV
   - Manual: `curl -LsSf https://astral.sh/uv/install.sh | sh`

2. **Permission Denied**
   - Ensure scripts are executable: `chmod +x pentest-toolkit`
   - Check file permissions on target directories

3. **Network Timeout**
   - Check network connectivity
   - Verify target is accessible
   - Consider using --timeout parameter

4. **SSL Certificate Errors**
   - Use HTTP for local testing
   - Add --skip-verify flag for testing only

### Debug Mode

Enable debug output:
```bash
uv run python tools/discover_structure.py https://target.com --debug
```

This enables:
- Verbose logging
- Request/response details
- Exception tracebacks
- Performance metrics

## Integration with Other Tools

### Using with Claude AI
The skill is designed for seamless integration with Claude:
```python
# Example Claude integration
def security_assessment(target):
    structure = run_tool("discover_structure", target)
    patterns = run_tool("analyze_responses", structure["responses"])
    tests = run_tool("generate_context_tests", structure, patterns)
    results = execute_tests(tests)
    return generate_report(results)
```

### Using with CI/CD
Integrate into pipelines:
```yaml
# GitHub Actions example
- name: Security Scan
  run: |
    ./pentest-toolkit --target ${{ env.API_URL }} --mode api
    python scripts/generate_report.py
```

### API Integration
All tools can be integrated via subprocess:
```python
import subprocess
import json

def run_tool(tool_name, *args):
    cmd = ["uv", "run", "python", f"tools/{tool_name}.py"] + list(args)
    result = subprocess.run(cmd, capture_output=True, text=True)
    return json.loads(result.stdout)
```

## Performance Optimization

### Caching
- Discovered structures are cached
- Pattern analysis results are stored
- Reuse across multiple targets

### Parallel Execution
- Tools support parallel execution
- Use with --parallel flag
- Independent tests run concurrently

### Resource Limits
- Memory usage is monitored
- Request rate limiting enforced
- Automatic backoff on failures