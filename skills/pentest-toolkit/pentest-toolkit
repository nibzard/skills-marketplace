#!/usr/bin/env python3
"""
AI-Powered Security Testing Toolkit - Improved Version
Non-interactive, simplified dependencies, enhanced detection
"""

import argparse
import sys
import os
import json
import subprocess
import shutil
import time
from pathlib import Path
from urllib.parse import urlparse

class SimpleToolkitManager:
    """Simplified toolkit manager without uv dependency"""

    def __init__(self):
        self.script_dir = Path(__file__).parent / "scripts"
        self.tools_dir = Path(__file__).parent / "tools"

    def run_script(self, script_name, args=None, capture_output=False):
        """Run a Python script directly"""
        script_path = self.script_dir / script_name
        if not script_path.exists():
            print(f"[-] Script not found: {script_path}")
            return False

        cmd = [sys.executable, str(script_path)]
        if args:
            cmd.extend(args)

        try:
            if capture_output:
                result = subprocess.run(cmd, capture_output=True, text=True)
                return result.stdout, result.stderr, result.returncode
            else:
                subprocess.run(cmd, check=True)
                return True
        except subprocess.CalledProcessError as e:
            print(f"[-] Error running {script_name}: {e}")
            return False
        except FileNotFoundError:
            print(f"[-] Python not found. Please install Python 3.")
            return False

def run_tool(tool_name, args=None, capture_output=False):
    """Run agent tool directly"""
    tools_dir = Path(__file__).parent / "tools"
    tool_path = tools_dir / tool_name

    if not tool_path.exists():
        print(f"[-] Tool not found: {tool_path}")
        return False

    cmd = [sys.executable, str(tool_path)]
    if args:
        cmd.extend(args)

    try:
        if capture_output:
            result = subprocess.run(cmd, capture_output=True, text=True)
            return result.stdout, result.stderr, result.returncode
        else:
            subprocess.run(cmd, check=True)
            return True
    except Exception as e:
        print(f"[-] Error running tool {tool_name}: {e}")
        return False

def analyze_response_errors(response_data):
    """Analyze responses for error disclosures"""
    vulnerabilities = []

    # Check for 500 errors with information disclosure
    if response_data.get('status_code') == 500:
        content = response_data.get('content', '').lower()

        if 'traceback' in content or 'stack trace' in content:
            vulnerabilities.append({
                'type': 'Stack Trace Disclosure',
                'severity': 'Medium',
                'description': 'Server is exposing stack traces in error responses'
            })

        if 'mysql' in content or 'postgresql' in content or 'sqlite' in content:
            vulnerabilities.append({
                'type': 'Database Information Disclosure',
                'severity': 'Medium',
                'description': 'Error messages reveal database type or structure'
            })

        if 'file path' in content or 'directory' in content:
            vulnerabilities.append({
                'type': 'Path Information Disclosure',
                'severity': 'Low',
                'description': 'Error messages reveal file system paths'
            })

    return vulnerabilities

def inspect_data_for_injections(data):
    """Inspect API responses for potential injection attacks"""
    findings = []

    injection_patterns = {
        'sql_injection': [
            r"('|(\\')|(;)|(\\-\\-)|(/\\*)|(\\*/))",
            r"union\s+select",
            r"or\s+1\s*=\s*1",
            r"drop\s+table",
            r"insert\s+into"
        ],
        'xss': [
            r"<script[^>]*>",
            r"javascript:",
            r"on\w+\s*=",
            r"<iframe[^>]*>",
            r"vbscript:"
        ],
        'path_traversal': [
            r"\.\./.*\.\.",
            r"%2e%2e%2f",
            r"\.\.\\",
            r"%2e%2e%5c"
        ]
    }

    def check_value(value, path):
        if isinstance(value, str):
            vuln_type = None
            for vuln, patterns in injection_patterns.items():
                for pattern in patterns:
                    import re
                    if re.search(pattern, value, re.IGNORECASE):
                        vuln_type = vuln
                        break
                if vuln_type:
                    break

            if vuln_type:
                findings.append({
                    'type': vuln_type,
                    'value': value[:100] + '...' if len(value) > 100 else value,
                    'path': path,
                    'severity': 'High' if vuln_type in ['sql_injection', 'xss'] else 'Medium'
                })
        elif isinstance(value, dict):
            for k, v in value.items():
                check_value(v, f"{path}.{k}")
        elif isinstance(value, list):
            for i, v in enumerate(value):
                check_value(v, f"{path}[{i}]")

    check_value(data, "root")
    return findings

def quick_enhanced_scan(target):
    """Enhanced quick scan with better error analysis"""
    print(f"[*] Starting enhanced security scan of {target}")

    # Run endpoint enumeration
    stdout, stderr, code = run_tool("discover_structure.py", [target], capture_output=True)

    if code == 0 and stdout:
        try:
            structure = json.loads(stdout)

            # Analyze discovered endpoints for error patterns
            vulnerabilities = []

            for endpoint in structure.get('discovered_endpoints', []):
                error_data = {
                    'status_code': endpoint.get('status'),
                    'content': ''
                }
                vulns = analyze_response_errors(error_data)
                vulnerabilities.extend(vulns)

            # Inspect data models for injections
            data_models = structure.get('data_models', {})
            injection_findings = inspect_data_for_injections(data_models)

            # Generate report
            report = {
                'target': target,
                'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
                'scan_type': 'enhanced_quick',
                'findings': {
                    'error_disclosures': vulnerabilities,
                    'potential_injections': injection_findings,
                    'discovered_endpoints': len(structure.get('discovered_endpoints', [])),
                    'data_models': list(structure.get('data_models', {}).keys())
                }
            }

            # Print results
            print("\n" + "="*60)
            print("ENHANCED SECURITY SCAN RESULTS")
            print("="*60)

            if vulnerabilities or injection_findings:
                print(f"\n[!] POTENTIAL VULNERABILITIES FOUND")

                for vuln in vulnerabilities:
                    print(f"\n  • {vuln['type']} ({vuln['severity']})")
                    print(f"    {vuln['description']}")

                for injection in injection_findings:
                    print(f"\n  • {injection['type'].replace('_', ' ').title()} ({injection['severity']})")
                    print(f"    Path: {injection['path']}")
                    print(f"    Value: {injection['value']}")

                print(f"\n[!] Total findings: {len(vulnerabilities) + len(injection_findings)}")
            else:
                print("\n[+] No obvious vulnerabilities detected in automated scan")

            print(f"\n[*] Discovered {report['findings']['discovered_endpoints']} endpoints")
            print(f"[*] Found {len(report['findings']['data_models'])} data models")

            return report

        except json.JSONDecodeError:
            print("[-] Failed to parse structure discovery results")

    else:
        print(f"[-] Structure discovery failed with code {code}")
        if stderr:
            print(f"Error: {stderr}")

    return None

def print_banner():
    """Print the toolkit banner"""
    print("="*60)
    print("AI-Powered Security Testing Toolkit - Enhanced")
    print("Non-interactive mode | Simplified dependencies")
    print("Enhanced error analysis & injection detection")
    print("="*60)

def main():
    """Main CLI entry point with non-interactive mode"""
    parser = argparse.ArgumentParser(
        prog='pentest-toolkit',
        description='AI-Powered Security Testing Toolkit - Enhanced',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --target https://example.com --auto
  %(prog)s --target https://example.com --enhanced
  %(prog)s --target https://example.com --mode comprehensive --no-confirm
  %(prog)s --discover-structure https://example.com

New Features:
  --auto          Run automated scan without prompts
  --enhanced      Enhanced quick scan with error analysis
  --no-confirm    Skip authorization confirmation
  --json          Output results in JSON format
  --discover-structure  Run structure discovery only
        """
    )

    parser.add_argument('--target', help='Target URL or IP address')
    parser.add_argument('--targets', help='File containing list of targets')
    parser.add_argument('--mode',
                       choices=['quick', 'comprehensive', 'api', 'endpoints', 'ports', 'sql', 'xss', 'enhanced'],
                       default='quick',
                       help='Testing mode (default: quick)')
    parser.add_argument('--auto', action='store_true',
                       help='Run in fully automated mode')
    parser.add_argument('--enhanced', action='store_true',
                       help='Run enhanced quick scan with error analysis')
    parser.add_argument('--no-confirm', action='store_true',
                       help='Skip authorization confirmation')
    parser.add_argument('--json', action='store_true',
                       help='Output results in JSON format')
    parser.add_argument('--discover-structure', action='store_true',
                       help='Run structure discovery only')
    parser.add_argument('--report', help='Generate report from previous scan results')
    parser.add_argument('--output', help='Save results to file')

    args = parser.parse_args()

    # Skip banner for JSON output
    if not args.json:
        print_banner()

    manager = SimpleToolkitManager()

    # Handle report generation
    if args.report:
        if not args.json:
            print("[*] Report generation not yet implemented")
        return 1

    # Handle structure discovery
    if args.discover_structure:
        if not args.target:
            if not args.json:
                print("[-] --target required for structure discovery")
            return 1
        if not args.json:
            print(f"[*] Discovering structure for {args.target}")
        stdout, stderr, code = run_tool("discover_structure.py", [args.target], capture_output=True)
        if code == 0 and args.json:
            print(stdout, end='')
        elif stdout:
            if not args.json:
                print("[+] Structure discovery complete")
        return 0

    # Check for target
    if not args.target and not args.targets:
        print("[-] --target or --targets required")
        return 1

    # Authorization check (can be skipped with --no-confirm or --auto)
    if not args.no_confirm and not args.auto:
        print("\n⚠️  IMPORTANT: This toolkit is for AUTHORIZED security testing only")
        print("    Ensure you have written permission before testing any target")
        try:
            response = input("\nDo you have authorization to test this target? (yes/no): ")
            if response.lower() not in ['yes', 'y']:
                print("Testing aborted. Authorization required.")
                return 1
        except KeyboardInterrupt:
            print("\nTesting aborted by user.")
            return 1
    elif args.auto or args.no_confirm:
        print("\n[*] Running in automated mode - authorization assumed")

    # Execute based on mode
    if args.mode == 'enhanced' or args.enhanced:
        if args.target:
            results = quick_enhanced_scan(args.target)
            if args.output and results:
                with open(args.output, 'w') as f:
                    json.dump(results, f, indent=2)
                print(f"\n[*] Results saved to {args.output}")
        return 0

    elif args.mode == 'comprehensive':
        print(f"\n[*] Running comprehensive security assessment...")
        manager.run_script('comprehensive_test.py', [args.target])

    elif args.mode == 'quick':
        print(f"\n[*] Running quick security scan...")
        manager.run_script('enumerate_endpoints.py', [args.target])

    elif args.mode == 'endpoints':
        print(f"\n[*] Enumerating endpoints...")
        stdout, stderr, code = run_tool("discover_structure.py", [args.target], capture_output=True)
        if args.json and stdout:
            print(stdout)

    elif args.mode == 'ports':
        print(f"\n[*] Scanning ports...")
        host = urlparse(args.target).netloc.split(':')[0]
        manager.run_script('scan_ports.py', [host])

    elif args.mode == 'sql':
        print(f"\n[*] Testing for SQL injection...")
        manager.run_script('test_sql_injection.py', [args.target])

    elif args.mode == 'xss':
        print(f"\n[*] Testing for XSS...")
        manager.run_script('test_xss.py', [args.target])

    elif args.mode == 'api':
        print(f"\n[*] Running API-focused security test...")
        manager.run_script('enumerate_endpoints.py', [args.target])

    print("\n[*] Scan complete")
    return 0

if __name__ == "__main__":
    sys.exit(main())