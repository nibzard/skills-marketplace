# Pentest-Toolkit Usage Examples

This document provides practical examples for using the AI-Powered Security Testing Toolkit, covering both human CLI usage and AI agent workflows.

## Quick Start Examples

### Basic Security Assessment
```bash
# Quick scan for obvious vulnerabilities
./pentest-toolkit --target https://example.com --mode quick

# Comprehensive assessment
./pentest-toolkit --target https://example.com --mode comprehensive

# API-focused testing
./pentest-toolkit --target https://api.example.com --mode api
```

## AI Agent Workflow Examples

### Complete Agent Workflow
```python
# Example: Claude AI agent performing security assessment

def full_security_assessment(target_url):
    """Complete security assessment workflow"""

    # Step 1: Discover application structure
    print("[*] Discovering application structure...")
    structure_cmd = f"uv run python scripts/discover_structure.py {target_url}"
    structure = execute_and_parse_json(structure_cmd)

    # Step 2: Analyze discovered patterns
    print("[*] Analyzing security patterns...")
    patterns_cmd = "uv run python scripts/analyze_responses.py responses.json"
    patterns = execute_and_parse_json(patterns_cmd)

    # Step 3: Generate context-aware tests
    print("[*] Generating targeted tests...")
    tests_cmd = "uv run python scripts/generate_context_tests.py structure.json patterns.json"
    tests = execute_and_parse_json(tests_cmd)

    # Step 4: Execute tests and collect results
    print("[*] Executing security tests...")
    results = execute_test_suite(tests)

    # Step 5: Generate comprehensive report
    print("[*] Generating security report...")
    report = generate_security_report(structure, patterns, tests, results)

    return report

# Execute the workflow
report = full_security_assessment("https://target-application.com")
```

### E-commerce Application Testing
```python
def test_ecommerce_application(target_url):
    """Specialized testing for e-commerce platforms"""

    # Discover structure
    structure = discover_structure(target_url)

    # Focus on e-commerce-specific vulnerabilities
    ecommerce_tests = [
        {
            "category": "business_logic",
            "tests": [
                "price_manipulation",
                "coupon_abuse",
                "inventory_bypass",
                "checkout_tampering"
            ]
        },
        {
            "category": "authorization",
            "tests": [
                "order_access_bypass",
                "user_profile_idor",
                "admin_panel_access"
            ]
        },
        {
            "category": "payment",
            "tests": [
                "payment_amount_tampering",
                "refund_abuse",
                "currency_manipulation"
            ]
        }
    ]

    # Generate and execute tests
    custom_tests = generate_ecommerce_tests(structure, ecommerce_tests)
    results = execute_tests(custom_tests)

    # Focus on business impact
    business_impact = analyze_business_impact(results)

    return generate_ecommerce_report(results, business_impact)

# Example usage
report = test_ecommerce_application("https://shop.example.com")
```

### API Security Testing Workflow
```python
def comprehensive_api_test(api_base_url):
    """Deep API security assessment"""

    # 1. API Discovery
    print("[*] Discovering API endpoints...")
    discovery_results = discover_api_endpoints(api_base_url)

    # 2. Authentication Analysis
    print("[*] Analyzing authentication...")
    auth_analysis = analyze_authentication_patterns(discovery_results)

    # 3. Authorization Testing
    print("[*] Testing authorization controls...")
    authz_tests = generate_authorization_tests(discovery_results)
    authz_results = execute_authorization_tests(authz_tests)

    # 4. Business Logic Testing
    print("[*] Testing business logic...")
    business_logic_results = test_api_business_logic(discovery_results)

    # 5. Data Validation Testing
    print("[*] Testing data validation...")
    validation_results = test_input_validation(discovery_results)

    # Generate API-specific report
    return generate_api_security_report({
        "discovery": discovery_results,
        "authentication": auth_analysis,
        "authorization": authz_results,
        "business_logic": business_logic_results,
        "validation": validation_results
    })

# Execute
api_report = comprehensive_api_test("https://api.example.com/v1")
```

## Real-World Scenarios

### Scenario 1: Startup SaaS Application
```python
def assess_saas_startup(target_url):
    """Security assessment for a B2B SaaS application"""

    # Discover multi-tenant architecture
    structure = discover_structure(target_url)

    # Test for tenant isolation
    tenant_tests = [
        "data_isolation_breach",
        "cross_tenant_access",
        "tenant_id_manipulation",
        "shared_resource_abuse"
    ]

    # Test subscription controls
    subscription_tests = [
        "feature_flag_bypass",
        "usage_limit_bypass",
        "trial_extension_abuse"
    ]

    # Test user management
    user_mgmt_tests = [
        "privilege_escalation",
        "role_assignment_abuse",
        "user_impersonation"
    ]

    # Execute focused test suite
    results = execute_saas_test_suite(
        structure,
        tenant_tests,
        subscription_tests,
        user_mgmt_tests
    )

    return generate_saas_report(results)

# Usage
saas_report = assess_saas_startup("https://app.startup.com")
```

### Scenario 2: Financial Services API
```python
def assess_financial_service(api_url):
    """Security assessment for financial services API"""

    # Discover financial endpoints
    structure = discover_structure(api_url)

    # Critical financial security tests
    financial_tests = {
        "transaction_security": [
            "amount_manipulation",
            "transaction_forgery",
            "double_spend_attack",
            "transaction_replay"
        ],
        "account_security": [
            "account_takeover",
            "balance_manipulation",
            "unauthorized_transfers",
            "account_enumeration"
        ],
        "data_protection": [
            "pii_exposure",
            "financial_data_leakage",
            "sensitive_info_disclosure"
        ]
    }

    # Execute with enhanced scrutiny
    results = execute_financial_tests(structure, financial_tests)

    # Compliance analysis
    compliance_check = check_pci_compliance(results)

    return generate_financial_security_report(results, compliance_check)

# Usage
financial_report = assess_financial_service("https://api.bank.com")
```

### Scenario 3: Social Media Platform
```python
def assess_social_media(target_url):
    """Security assessment for social media platform"""

    # Discover social features
    structure = discover_structure(target_url)

    # Social media specific tests
    social_tests = {
        "privacy_controls": [
            "private_profile_access",
            "friend_list_enumeration",
            "message_interception",
            "content_visibility_bypass"
        ],
        "interaction_abuse": [
            "like_manipulation",
            "fake_engagement",
            "spam_propagation",
            "harassment_tools"
        ],
        "account_security": [
            "profile_takeover",
            "credential_stuffing",
            "session_hijacking",
            "oauth_abuse"
        ]
    }

    # Test content policies
    content_policy_tests = test_content_policy_implementation(structure)

    # Execute social media test suite
    results = execute_social_tests(structure, social_tests)

    # Analyze privacy impact
    privacy_impact = assess_privacy_vulnerabilities(results)

    return generate_social_media_report(results, privacy_impact, content_policy_tests)

# Usage
social_report = assess_social_media("https://social.example.com")
```

## Sample Outputs

### Structure Discovery Output
```json
{
  "base_url": "https://shop.example.com",
  "discovered_endpoints": [
    {
      "url": "/api/products",
      "method": ["GET", "POST"],
      "status": 200,
      "content_type": "application/json"
    },
    {
      "url": "/api/orders",
      "method": ["GET", "POST"],
      "status": 200,
      "auth_required": true
    },
    {
      "url": "/api/users/{user_id}/orders",
      "method": ["GET"],
      "status": 200,
      "auth_required": true
    }
  ],
  "data_models": {
    "product": {
      "fields": {
        "id": {"type": "string"},
        "price": {"type": "number"},
        "inventory": {"type": "integer"}
      }
    },
    "order": {
      "fields": {
        "id": {"type": "string"},
        "user_id": {"type": "string"},
        "total": {"type": "number"},
        "status": {"type": "string"}
      }
    }
  },
  "business_entities": ["product", "order", "user", "cart"],
  "vulnerability_indicators": [
    {
      "type": "IDOR_PATTERN",
      "location": "/api/users/{user_id}/orders",
      "severity": "HIGH"
    }
  ]
}
```

### Generated Test Scenario
```json
{
  "test_scenarios": [
    {
      "id": "order_access_idor",
      "name": "Order Access IDOR Test",
      "category": "authorization",
      "risk_level": "HIGH",
      "target_endpoints": ["/api/users/{user_id}/orders"],
      "test_cases": [
        {
          "description": "Access orders of different user",
          "method": "GET",
          "url": "/api/users/OTHER_USER_ID/orders",
          "headers": {
            "Authorization": "Bearer USER_A_TOKEN"
          },
          "expected_indicators": {
            "success": ["200", "orders list"],
            "vulnerability": ["200", "orders not belonging to user"]
          }
        }
      ]
    }
  ]
}
```

### Final Report Summary
```markdown
# Security Assessment Report

## Executive Summary
- **Critical Vulnerabilities**: 2
- **High Risk**: 5
- **Medium Risk**: 12
- **Low Risk**: 8

## Critical Findings

### 1. Insecure Direct Object Reference (IDOR)
- **Location**: `/api/users/{user_id}/orders`
- **Impact**: Users can access other users' order history
- **Risk Level**: CRITICAL
- **Remediation**: Implement proper ownership checks

### 2. Price Manipulation
- **Location**: `/api/orders`
- **Impact**: Users can modify order prices during checkout
- **Risk Level**: CRITICAL
- **Remediation**: Server-side price validation

## Recommendations
1. Implement proper authorization controls
2. Add server-side validation for all financial operations
3. Encrypt sensitive data in transit and at rest
4. Implement rate limiting and monitoring
```

## Advanced Usage Examples

### Custom Pattern Integration
```python
def add_custom_business_logic_patterns():
    """Add organization-specific vulnerability patterns"""

    custom_patterns = {
        "custom_workflows": [
            {
                "name": "approval_chain_bypass",
                "description": "Bypass multi-level approval process",
                "indicators": [
                    "direct API calls to approve actions",
                    "missing approval checks"
                ],
                "test_method": "submit high-value action without approvals"
            }
        ]
    }

    # Integrate with existing patterns
    patterns = load_patterns("patterns/business_logic.json")
    patterns["pattern_categories"].append(custom_patterns)

    return patterns

# Use custom patterns
patterns = add_custom_business_logic_patterns()
tests = generate_tests_with_patterns(structure, patterns)
```

### Continuous Security Monitoring
```python
def continuous_monitoring(targets):
    """Continuous security monitoring pipeline"""

    while True:
        for target in targets:
            # Quick assessment
            quick_results = quick_security_scan(target)

            # If issues found, perform deep analysis
            if quick_results["high_risk_count"] > 0:
                deep_analysis = comprehensive_assessment(target)
                alert_team(deep_analysis)

            # Sleep before next check
            time.sleep(3600)  # Check every hour

# Monitor multiple applications
targets = [
    "https://api.production.com",
    "https://api.staging.com"
]
continuous_monitoring(targets)
```

## Integration Examples

### Claude Code Integration
```bash
# Direct skill invocation
skill: "pentest-toolkit"

# Claude will prompt for target and mode
# Or specify directly
I need to perform a security assessment on https://myapp.com using the pentest-toolkit skill
```

### CI/CD Pipeline Integration
```yaml
# .github/workflows/security-scan.yml
name: Security Scan

on:
  pull_request:
    branches: [main]
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM

jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2

    - name: Setup Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.9'

    - name: Run Security Scan
      run: |
        ./pentest-toolkit --target ${{ env.STAGING_URL }} --mode api
        python scripts/generate_report.py

    - name: Upload Results
      uses: actions/upload-artifact@v2
      with:
        name: security-report
        path: security_report.md
```

### Slack Integration
```python
def slack_integration_security_alert(severity, findings):
    """Send security alerts to Slack"""

    slack_webhook = os.getenv("SLACK_WEBHOOK_URL")

    message = {
        "text": f"ðŸš¨ Security Alert - {severity} Severity",
        "attachments": [
            {
                "color": "danger" if severity == "CRITICAL" else "warning",
                "fields": [
                    {
                        "title": "Vulnerabilities Found",
                        "value": str(len(findings)),
                        "short": True
                    },
                    {
                        "title": "Recommendation",
                        "value": "Immediate security review required",
                        "short": True
                    }
                ]
            }
        ]
    }

    requests.post(slack_webhook, json=message)

# Use in security workflow
if critical_findings:
    slack_integration_security_alert("CRITICAL", critical_findings)
```

## Best Practices

### For Human Users
1. Always get authorization before testing
2. Start with quick scan before comprehensive testing
3. Review results carefully for false positives
4. Test in staging environments first

### For AI Agents
1. Always use `uv run python` for script execution
2. Cache discovery results to avoid repeated requests
3. Implement rate limiting between requests
4. Validate and sanitize all inputs
5. Generate human-readable reports for final output

### Error Handling
```python
def robust_security_assessment(target):
    """Security assessment with comprehensive error handling"""

    try:
        structure = discover_structure(target)
    except NetworkError:
        return {"error": "Target unreachable", "suggestion": "Check URL and network"}
    except AuthenticationError:
        return {"error": "Authentication required", "suggestion": "Provide valid credentials"}

    try:
        tests = generate_tests(structure)
    except PatternError:
        return {"error": "Pattern generation failed", "suggestion": "Review application structure"}

    # Continue with robust error handling...
```