"""
Command-line interface for the AI-Powered Security Testing Toolkit
Uses uv for script execution and environment management
"""

import sys
import os
import argparse
import subprocess
import json
from pathlib import Path
from typing import List, Optional

class ToolkitManager:
    """Manages toolkit execution using uv"""

    def __init__(self):
        self.script_dir = Path(__file__).parent.parent / "scripts"
        self.project_root = Path(__file__).parent.parent

    def check_uv(self) -> bool:
        """Check if uv is available"""
        try:
            result = subprocess.run(['uv', '--version'], capture_output=True, text=True)
            return result.returncode == 0
        except FileNotFoundError:
            return False

    def install_uv(self) -> bool:
        """Install uv if not available"""
        print("Installing uv (Python package manager)...")
        try:
            # Install uv using the official installer
            install_script = '''
            curl -LsSf https://astral.sh/uv/install.sh | sh
            '''
            result = subprocess.run(install_script, shell=True, capture_output=True)
            return result.returncode == 0
        except Exception as e:
            print(f"Failed to install uv: {e}")
            return False

    def run_with_uv(self, script_name: str, args: List[str]) -> bool:
        """Run a script using uv"""
        script_path = self.script_dir / script_name

        if not script_path.exists():
            print(f"[-] Script not found: {script_name}")
            return False

        try:
            # Use uv run to execute the script
            cmd = ['uv', 'run', '--no-project', '--python', 'python3', str(script_path)] + args
            print(f"[*] Executing: {' '.join(cmd)}")

            result = subprocess.run(cmd, cwd=self.project_root)
            return result.returncode == 0

        except Exception as e:
            print(f"[-] Error running {script_name}: {e}")
            return False

    def run_script(self, script_name: str, args: List[str]) -> bool:
        """Run a script (fallback without uv)"""
        script_path = self.script_dir / script_name

        if not script_path.exists():
            print(f"[-] Script not found: {script_name}")
            return False

        try:
            cmd = ['python3', str(script_path)] + args
            print(f"[*] Executing: {' '.join(cmd)}")

            result = subprocess.run(cmd)
            return result.returncode == 0

        except Exception as e:
            print(f"[-] Error running {script_name}: {e}")
            return False

    def setup_environment(self):
        """Setup the Python environment using uv"""
        if not self.check_uv():
            print("[*] uv not found. Installing...")
            if not self.install_uv():
                print("[-] Failed to install uv. Falling back to system Python")
                return False
            print("[+] uv installed successfully")

        # Create virtual environment if needed
        venv_path = self.project_root / ".venv"
        if not venv_path.exists():
            print("[*] Creating virtual environment...")
            result = subprocess.run(['uv', 'venv'], cwd=self.project_root)
            if result.returncode != 0:
                print("[-] Failed to create virtual environment")
                return False
            print("[+] Virtual environment created")

        return True

def print_banner():
    """Print the toolkit banner"""
    print("="*60)
    print("AI-Powered Security Testing Toolkit")
    print("Enhanced with Astral uv for Python management")
    print("="*60)

def print_available_tools():
    """List available security testing tools"""
    print("Available Security Testing Tools:")
    print("="*50)
    tools = [
        ("enumerate_endpoints.py", "Discover web application endpoints and APIs"),
        ("scan_ports.py", "Scan for open ports and services"),
        ("test_sql_injection.py", "Test for SQL injection vulnerabilities"),
        ("test_xss.py", "Test for Cross-Site Scripting (XSS)"),
        ("comprehensive_test.py", "Run all tests in coordinated manner"),
        ("generate_report.py", "Generate security reports from results")
    ]
    for tool, description in tools:
        print(f"  {tool:<30} - {description}")
    print()
    print("Execution Methods:")
    print("  - uv run (recommended): Uses Astral uv for isolated execution")
    print("  - python3 fallback: Direct execution if uv unavailable")

def main():
    """Main CLI entry point"""
    parser = argparse.ArgumentParser(
        prog='pentest-toolkit',
        description='AI-Powered Security Testing Toolkit (uv-enhanced)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --target https://example.com --mode quick
  %(prog)s --target https://example.com --mode comprehensive
  %(prog)s --target https://example.com --mode api
  %(prog)s --targets targets.txt --parallel 3
  %(prog)s --report /path/to/results.json

Testing Modes:
  quick       - Basic vulnerability scanning (recommended for initial assessment)
  comprehensive - Full penetration testing with all tools
  api        - API-focused security testing
  endpoints  - Endpoint enumeration only
  ports      - Port scanning only
  sql        - SQL injection testing only
  xss        - XSS testing only

Environment:
  --uv        - Force use of uv for script execution
  --no-uv     - Use system Python directly
        """
    )

    parser.add_argument('--target', '-t', help='Target URL to test')
    parser.add_argument('--targets', help='File containing list of targets (one per line)')
    parser.add_argument('--mode', '-m',
                       choices=['quick', 'comprehensive', 'api', 'endpoints', 'ports', 'sql', 'xss'],
                       default='comprehensive',
                       help='Testing mode (default: comprehensive)')
    parser.add_argument('--parallel', '-p', type=int, default=1,
                       help='Number of parallel tests (default: 1)')
    parser.add_argument('--report', '-r', help='Generate report from existing results')
    parser.add_argument('--output', '-o', help='Output directory for results')
    parser.add_argument('--list-tools', action='store_true',
                       help='List available security testing tools')
    parser.add_argument('--examples', action='store_true',
                       help='Show usage examples')
    parser.add_argument('--uv', action='store_true',
                       help='Force use of uv for execution')
    parser.add_argument('--no-uv', action='store_true',
                       help='Use system Python directly (no uv)')
    parser.add_argument('--setup', action='store_true',
                       help='Setup uv environment only')

    args = parser.parse_args()

    manager = ToolkitManager()
    use_uv = False

    # Determine execution method
    if args.no_uv:
        use_uv = False
        print("[*] Using system Python (no uv)")
    elif args.uv or manager.check_uv():
        use_uv = True
        print("[*] Using Astral uv for execution")
    else:
        print("[*] uv not available, using system Python")
        use_uv = False

    # Setup environment
    if use_uv and args.setup:
        if manager.setup_environment():
            print("[+] Environment setup complete")
        else:
            print("[-] Environment setup failed")
            sys.exit(1)
        return

    # Show tool list
    if args.list_tools:
        print_available_tools()
        return

    # Show examples
    if args.examples:
        print("Usage Examples:")
        print("="*50)
        print("# Quick security scan")
        print("pentest-toolkit --target https://example.com --mode quick")
        print()
        print("# Comprehensive penetration test")
        print("pentest-toolkit --target https://example.com --mode comprehensive")
        print()
        print("# API security testing")
        print("pentest-toolkit --target https://api.example.com --mode api")
        print()
        print("# Multi-target scanning")
        print("pentest-toolkit --targets targets.txt --parallel 3")
        print()
        print("# Setup uv environment")
        print("pentest-toolkit --setup")
        print()
        print("# Force uv execution")
        print("pentest-toolkit --target https://example.com --uv")
        return

    # Report generation mode
    if args.report:
        if use_uv:
            return manager.run_with_uv('generate_report.py', [args.report])
        else:
            return manager.run_script('generate_report.py', [args.report])

    # Validate target
    if not args.target and not args.targets:
        parser.error("Target URL or targets file is required")

    # Set output directory
    if args.output:
        os.makedirs(args.output, exist_ok=True)
        os.chdir(args.output)

    # Print banner and check authorization
    print_banner()
    print()
    print("⚠️  IMPORTANT: This toolkit is for AUTHORIZED security testing only")
    print("    Ensure you have written permission before testing any target")
    print()

    try:
        response = input("Do you have authorization to test this target? (yes/no): ")
        if response.lower() not in ['yes', 'y']:
            print("Testing aborted. Authorization required.")
            sys.exit(1)
    except KeyboardInterrupt:
        print("\nTesting aborted by user.")
        sys.exit(1)

    # Execute based on mode
    run_func = manager.run_with_uv if use_uv else manager.run_script

    if args.mode == 'comprehensive':
        print("\n[*] Running comprehensive security assessment...")
        run_func('comprehensive_test.py', [args.target])

    elif args.mode == 'quick':
        print("\n[*] Running quick security scan...")
        run_func('enumerate_endpoints.py', [args.target])
        run_func('test_sql_injection.py', [args.target])
        run_func('test_xss.py', [args.target])

    elif args.mode == 'endpoints':
        print("\n[*] Enumerating endpoints...")
        run_func('enumerate_endpoints.py', [args.target])

    elif args.mode == 'ports':
        print("\n[*] Scanning ports...")
        from urllib.parse import urlparse
        host = urlparse(args.target).netloc.split(':')[0]
        run_func('scan_ports.py', [host])

    elif args.mode == 'sql':
        print("\n[*] Testing for SQL injection...")
        run_func('test_sql_injection.py', [args.target])

    elif args.mode == 'xss':
        print("\n[*] Testing for XSS...")
        run_func('test_xss.py', [args.target])

    elif args.mode == 'api':
        print("\n[*] Running API-focused security test...")
        run_func('enumerate_endpoints.py', [args.target])
        # Focus on API-specific tests would go here

    # Multi-target mode
    if args.targets and args.parallel > 1:
        print(f"\n[*] Running tests on {args.parallel} targets in parallel...")
        # Implementation would use threading/multiprocessing

    print("\n[*] Security testing complete!")
    execution_method = "uv" if use_uv else "system Python"
    print(f"[*] Execution method: {execution_method}")
    print("[*] Check generated JSON files for detailed results")
    print("[*] Run 'pentest-toolkit --report' for a comprehensive report")

if __name__ == "__main__":
    main()