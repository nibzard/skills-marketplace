#!/usr/bin/env python3
"""
Agent tool: Generate context-aware tests based on discovered application structure
Creates targeted test code and scenarios based on patterns and discovered data
"""

import json
import sys
import os
from typing import Dict, List, Any, Optional
from pathlib import Path

class ContextAwareTestGenerator:
    """
    Generates targeted security tests based on discovered application structure
    Designed for agent consumption (JSON output, no prompts)
    """

    def __init__(self):
        self.patterns_dir = Path(__file__).parent.parent / "patterns"
        self.templates_dir = Path(__file__).parent.parent / "templates"
        self.load_patterns()

    def load_patterns(self):
        """Load vulnerability patterns from pattern files"""
        self.business_logic_patterns = {}
        self.data_relationship_patterns = {}

        try:
            with open(self.patterns_dir / "business_logic.json", 'r') as f:
                self.business_logic_patterns = json.load(f)
        except Exception as e:
            print(f"Warning: Could not load business logic patterns: {e}", file=sys.stderr)

        try:
            with open(self.patterns_dir / "data_relationships.json", 'r') as f:
                self.data_relationship_patterns = json.load(f)
        except Exception as e:
            print(f"Warning: Could not load data relationship patterns: {e}", file=sys.stderr)

    def generate_tests_from_structure(self, app_structure: Dict[str, Any]) -> Dict[str, Any]:
        """Generate tests based on discovered application structure"""
        generated_tests = {
            'test_scenarios': [],
            'test_code': {},
            'targeted_vulnerabilities': [],
            'test_priorities': {},
            'execution_plan': []
        }

        # Extract key information from app structure
        endpoints = app_structure.get('discovered_endpoints', [])
        business_entities = app_structure.get('business_entities', [])
        data_models = app_structure.get('data_models', {})
        auth_patterns = app_structure.get('authentication_patterns', {})

        # Generate tests for each vulnerability pattern
        for pattern_name, pattern_data in self.business_logic_patterns.get('patterns', {}).items():
            test_scenario = self.generate_pattern_test(pattern_name, pattern_data, app_structure)
            if test_scenario:
                generated_tests['test_scenarios'].append(test_scenario)
                generated_tests['targeted_vulnerabilities'].append(pattern_name)

        # Generate relationship-based tests
        if self.data_relationship_patterns:
            relationship_tests = self.generate_relationship_tests(app_structure)
            generated_tests['test_scenarios'].extend(relationship_tests)

        # Generate entity-specific tests
        entity_tests = self.generate_entity_tests(business_entities, endpoints, data_models)
        generated_tests['test_scenarios'].extend(entity_tests)

        # Prioritize tests based on risk and coverage
        generated_tests['test_priorities'] = self.prioritize_tests(generated_tests['test_scenarios'])
        generated_tests['execution_plan'] = self.create_execution_plan(generated_tests['test_scenarios'])

        # Generate actual test code
        generated_tests['test_code'] = self.generate_test_code(generated_tests['test_scenarios'])

        return generated_tests

    def generate_pattern_test(self, pattern_name: str, pattern_data: Dict[str, Any],
                            app_structure: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Generate test for a specific vulnerability pattern"""
        endpoints = app_structure.get('discovered_endpoints', [])
        business_entities = app_structure.get('business_entities', [])

        # Check if pattern is relevant to discovered structure
        if not self.is_pattern_relevant(pattern_data, app_structure):
            return None

        test_scenario = {
            'pattern_name': pattern_name,
            'test_name': f"{pattern_name}_test",
            'description': pattern_data.get('description', ''),
            'test_strategy': pattern_data.get('test_strategy', ''),
            'target_endpoints': [],
            'test_cases': [],
            'indicators_found': [],
            'risk_level': self.calculate_pattern_risk(pattern_data, app_structure)
        }

        # Find relevant indicators in app structure
        indicators = pattern_data.get('indicators', [])
        found_indicators = []
        for indicator in indicators:
            if self.find_indicator_in_structure(indicator, app_structure):
                found_indicators.append(indicator)

        test_scenario['indicators_found'] = found_indicators

        # Find target endpoints
        common_endpoints = pattern_data.get('common_endpoints', [])
        relevant_endpoints = []

        for endpoint_pattern in common_endpoints:
            matching_endpoints = self.find_matching_endpoints(endpoint_pattern, endpoints)
            relevant_endpoints.extend(matching_endpoints)

        test_scenario['target_endpoints'] = relevant_endpoints

        # Generate test cases
        test_cases = pattern_data.get('test_cases', [])
        for test_case in test_cases:
            generated_case = self.generate_test_case(test_case, app_structure)
            if generated_case:
                test_scenario['test_cases'].append(generated_case)

        return test_scenario if test_scenario['target_endpoints'] else None

    def generate_relationship_tests(self, app_structure: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate tests based on data relationships"""
        relationship_tests = []
        endpoints = app_structure.get('discovered_endpoints', [])
        data_models = app_structure.get('data_models', {})

        if not self.data_relationship_patterns:
            return relationship_tests

        # Analyze discovered data relationships
        discovered_relationships = self.analyze_data_relationships(data_models, endpoints)

        for relationship in discovered_relationships:
            test_scenario = {
                'pattern_name': 'data_relationship_abuse',
                'test_name': f"relationship_test_{relationship['type']}",
                'description': f"Test for vulnerabilities in {relationship['type']} relationships",
                'test_strategy': 'Manipulate relationship parameters to test access controls',
                'target_endpoints': relationship.get('endpoints', []),
                'test_cases': self.generate_relationship_test_cases(relationship),
                'indicators_found': relationship.get('indicators', []),
                'risk_level': 'HIGH' if relationship.get('involves_user_data') else 'MEDIUM'
            }
            relationship_tests.append(test_scenario)

        return relationship_tests

    def generate_entity_tests(self, business_entities: List[str], endpoints: List[Dict[str, Any]],
                            data_models: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate entity-specific tests"""
        entity_tests = []

        for entity in business_entities:
            entity_endpoints = self.find_matching_endpoints(entity, endpoints)
            if not entity_endpoints:
                continue

            test_scenario = {
                'pattern_name': 'entity_security',
                'test_name': f"{entity}_security_test",
                'description': f"Test security controls for {entity} entity",
                'test_strategy': f'Test CRUD operations, authorization, and data validation for {entity}',
                'target_endpoints': entity_endpoints,
                'test_cases': self.generate_entity_test_cases(entity, entity_endpoints, data_models),
                'indicators_found': [entity],
                'risk_level': 'HIGH' if entity in ['user', 'admin', 'account'] else 'MEDIUM'
            }
            entity_tests.append(test_scenario)

        return entity_tests

    def is_pattern_relevant(self, pattern_data: Dict[str, Any], app_structure: Dict[str, Any]) -> bool:
        """Check if a vulnerability pattern is relevant to the discovered structure"""
        indicators = pattern_data.get('indicators', [])
        if not indicators:
            return True  # Generic pattern, always test

        # Check if any indicators are found in the app structure
        for indicator in indicators:
            if self.find_indicator_in_structure(indicator, app_structure):
                return True

        return False

    def find_indicator_in_structure(self, indicator: str, app_structure: Dict[str, Any]) -> bool:
        """Search for indicator in application structure"""
        # Search in endpoints
        endpoints = app_structure.get('discovered_endpoints', [])
        for endpoint in endpoints:
            path = endpoint.get('path', '') + endpoint.get('url', '')
            if indicator.lower() in path.lower():
                return True

        # Search in data models
        data_models = app_structure.get('data_models', {})
        for model_name, model_data in data_models.items():
            if indicator.lower() in model_name.lower():
                return True
            if isinstance(model_data, dict) and 'fields' in model_data:
                for field_name in model_data['fields']:
                    if indicator.lower() in field_name.lower():
                        return True

        # Search in business entities
        business_entities = app_structure.get('business_entities', [])
        for entity in business_entities:
            if indicator.lower() in entity.lower():
                return True

        return False

    def find_matching_endpoints(self, pattern: str, endpoints: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Find endpoints that match a pattern"""
        matching_endpoints = []

        # Extract core pattern from endpoint template
        # e.g., "GET /users/{id}/profile" -> "/users"
        core_pattern = pattern.split('/')[1] if '/' in pattern else pattern.split('/')[0]

        for endpoint in endpoints:
            path = endpoint.get('path', '') + endpoint.get('url', '')
            if core_pattern.lower() in path.lower():
                matching_endpoints.append(endpoint)

        return matching_endpoints

    def generate_test_case(self, test_case_template: Dict[str, Any], app_structure: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Generate a specific test case from template"""
        return {
            'description': test_case_template.get('description', ''),
            'method': test_case_template.get('method', ''),
            'payloads': test_case_template.get('payload_variations', []),
            'expected_outcomes': [
                'Successful unauthorized access indicates vulnerability',
                'Error responses should be analyzed for information disclosure'
            ]
        }

    def analyze_data_relationships(self, data_models: Dict[str, Any], endpoints: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Analyze data relationships from models and endpoints"""
        relationships = []

        # Extract relationships from data models
        for model_name, model_data in data_models.items():
            if isinstance(model_data, dict) and 'relationships' in model_data:
                for rel in model_data['relationships']:
                    relationships.append({
                        'type': 'model_defined',
                        'from_entity': model_name,
                        'to_entity': rel.get('field', ''),
                        'indicators': [rel.get('pattern', '')],
                        'endpoints': self.find_entity_endpoints(model_name, endpoints)
                    })

        # Extract relationships from endpoint patterns
        for endpoint in endpoints:
            path = endpoint.get('path', '') + endpoint.get('url', '')
            if '_id' in path.lower() or 'user' in path.lower():
                relationships.append({
                    'type': 'endpoint_pattern',
                    'from_entity': self.extract_entity_from_path(path),
                    'to_entity': 'unknown',
                    'indicators': ['id_relationship', 'resource_relationship'],
                    'endpoints': [endpoint],
                    'involves_user_data': 'user' in path.lower()
                })

        return relationships

    def generate_relationship_test_cases(self, relationship: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate test cases for relationship vulnerabilities"""
        test_cases = []

        # IDOR test cases
        if relationship.get('indicators'):
            test_cases.append({
                'description': 'Insecure Direct Object Reference test',
                'method': 'Modify relationship identifiers to access unauthorized data',
                'payloads': [
                    {'resource_id': 'other_user_id'},
                    {'user_id': 'attacker_user_id'},
                    {'owner_id': 'modified_owner_id'}
                ],
                'expected_outcomes': [
                    'Unauthorized access indicates IDOR vulnerability',
                    'Proper access controls should return 403/404'
                ]
            })

        # Relationship manipulation test cases
        test_cases.append({
            'description': 'Relationship manipulation test',
            'method': 'Try to modify or inject relationship data',
            'payloads': [
                {'relationship_id': 'malicious_value'},
                {'foreign_key': 'invalid_reference'},
                {'parent_id': 'unauthorized_parent'}
            ],
            'expected_outcomes': [
                'Successful manipulation indicates validation issues',
                'Proper validation should reject invalid relationships'
            ]
        })

        return test_cases

    def generate_entity_test_cases(self, entity: str, endpoints: List[Dict[str, Any]],
                                 data_models: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate entity-specific test cases"""
        test_cases = []

        # CRUD operation tests
        crud_operations = self.get_crud_operations_for_entity(entity, endpoints)
        for operation in crud_operations:
            test_cases.append({
                'description': f'{entity} {operation["method"]} authorization test',
                'method': f'Test {operation["method"]} operations on {entity} with different user contexts',
                'payloads': self.generate_entity_payloads(entity, operation, data_models),
                'expected_outcomes': [
                    'Proper authorization should prevent unauthorized operations',
                    'Authorization bypass indicates security vulnerability'
                ]
            })

        return test_cases

    def get_crud_operations_for_entity(self, entity: str, endpoints: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Extract CRUD operations for an entity from endpoints"""
        crud_ops = []

        for endpoint in endpoints:
            path = endpoint.get('path', '') + endpoint.get('url', '')
            methods = endpoint.get('methods', [])

            if entity.lower() in path.lower():
                for method in methods:
                    crud_ops.append({
                        'endpoint': path,
                        'method': method,
                        'path_params': self.extract_path_params(path)
                    })

        return crud_ops

    def generate_entity_payloads(self, entity: str, operation: Dict[str, Any],
                               data_models: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate test payloads for entity operations"""
        payloads = []

        # Base payload structure
        base_payload = {
            f'{entity}_name': 'test_value',
            'description': 'test description',
            'status': 'active'
        }

        # Add relationship payloads if data model indicates relationships
        if entity in data_models:
            model_data = data_models[entity]
            if isinstance(model_data, dict) and 'relationships' in model_data:
                for rel in model_data['relationships']:
                    if 'id' in rel.get('field', '').lower():
                        base_payload[rel['field']] = 'modified_id'

        payloads.append(base_payload)

        # Add malicious payloads
        malicious_payloads = [
            {**base_payload, 'user_id': 'other_user_id'},
            {**base_payload, 'owner_id': 'unauthorized_id'},
            {**base_payload, 'status': 'unauthorized_status_change'}
        ]

        payloads.extend(malicious_payloads)

        return payloads

    def extract_path_params(self, path: str) -> List[str]:
        """Extract path parameters from endpoint path"""
        import re
        # Look for patterns like {id}, :id, /id/
        param_patterns = [r'\{([^}]+)\}', r':([^/]+)', r'/([^/]+)/[^/]+/?$']
        params = []
        for pattern in param_patterns:
            matches = re.findall(pattern, path)
            params.extend(matches)
        return list(set(params))

    def extract_entity_from_path(self, path: str) -> str:
        """Extract entity name from API path"""
        segments = [seg for seg in path.split('/') if seg and not seg.startswith('{') and seg != 'api' and seg != 'v1']
        return segments[0] if segments else 'unknown'

    def calculate_pattern_risk(self, pattern_data: Dict[str, Any], app_structure: Dict[str, Any]) -> str:
        """Calculate risk level for a pattern based on application structure"""
        base_risk = 'MEDIUM'

        # High-risk indicators
        high_risk_patterns = ['authorization_bypass', 'privilege_escalation', 'state_manipulation']
        if pattern_data.get('name', '') in high_risk_patterns:
            base_risk = 'HIGH'

        # Check if pattern involves user data
        if self.involves_user_data(pattern_data, app_structure):
            base_risk = 'HIGH'

        # Check for admin endpoints
        auth_patterns = app_structure.get('authentication_patterns', {})
        if auth_patterns.get('login_endpoints') or auth_patterns.get('session_management'):
            base_risk = 'HIGH'

        return base_risk

    def involves_user_data(self, pattern_data: Dict[str, Any], app_structure: Dict[str, Any]) -> bool:
        """Check if pattern involves user data or authentication"""
        user_indicators = ['user', 'auth', 'session', 'permission', 'role']

        # Check pattern indicators
        indicators = pattern_data.get('indicators', [])
        if any(any(indicator in ind for indicator in user_indicators)
               for ind in indicators):
            return True

        # Check common endpoints
        common_endpoints = pattern_data.get('common_endpoints', [])
        if any('admin' in endpoint or 'auth' in endpoint or 'user' in endpoint
               for endpoint in common_endpoints):
            return True

        return False

    def prioritize_tests(self, test_scenarios: List[Dict[str, Any]]) -> Dict[str, int]:
        """Prioritize tests based on risk and coverage"""
        priorities = {}

        for i, scenario in enumerate(test_scenarios):
            risk_level = scenario.get('risk_level', 'MEDIUM')
            base_priority = {'HIGH': 3, 'MEDIUM': 2, 'LOW': 1}.get(risk_level, 2)

            # Adjust priority based on coverage
            endpoint_count = len(scenario.get('target_endpoints', []))
            test_case_count = len(scenario.get('test_cases', []))

            # More targets and test cases = higher priority
            coverage_bonus = min(endpoint_count // 2, 2) + min(test_case_count // 3, 1)

            priorities[scenario['test_name']] = base_priority + coverage_bonus

        return priorities

    def create_execution_plan(self, test_scenarios: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Create ordered execution plan for tests"""
        # Sort by risk level (HIGH first) then by priority
        sorted_scenarios = sorted(test_scenarios,
                                key=lambda x: ({'HIGH': 3, 'MEDIUM': 2, 'LOW': 1}[x.get('risk_level', 'MEDIUM')],
                                          len(x.get('target_endpoints', []))),
                                reverse=True)

        execution_plan = []
        for scenario in sorted_scenarios:
            execution_plan.append({
                'test_name': scenario['test_name'],
                'pattern': scenario['pattern_name'],
                'risk_level': scenario['risk_level'],
                'estimated_duration': self.estimate_test_duration(scenario),
                'dependencies': []
            })

        return execution_plan

    def estimate_test_duration(self, scenario: Dict[str, Any]) -> str:
        """Estimate test execution duration"""
        endpoint_count = len(scenario.get('target_endpoints', []))
        test_case_count = len(scenario.get('test_cases', []))

        total_tests = endpoint_count * max(test_case_count, 1)

        if total_tests < 10:
            return 'SHORT (< 2 minutes)'
        elif total_tests < 50:
            return 'MEDIUM (2-5 minutes)'
        else:
            return 'LONG (> 5 minutes)'

    def generate_test_code(self, test_scenarios: List[Dict[str, Any]]) -> Dict[str, str]:
        """Generate actual test code for scenarios"""
        test_code = {}

        for scenario in test_scenarios:
            code = self.generate_scenario_test_code(scenario)
            test_code[scenario['test_name']] = code

        return test_code

    def generate_scenario_test_code(self, scenario: Dict[str, Any]) -> str:
        """Generate Python test code for a scenario"""
        test_name = scenario['test_name']
        description = scenario['description']
        target_endpoints = scenario.get('target_endpoints', [])
        test_cases = scenario.get('test_cases', [])

        code = f'''#!/usr/bin/env python3
"""
Auto-generated test for {test_name}
Description: {description}
"""

import requests
import json
import sys

class {test_name.title().replace('_', '')}Test:
    def __init__(self, base_url):
        self.base_url = base_url
        self.session = requests.Session()
        self.vulnerabilities_found = []

    def run_all_tests(self):
        """Run all test cases for this scenario"""
        print(f"[*] Running {test_name}")
'''

        # Add test case methods
        for i, test_case in enumerate(test_cases):
            method_name = f"test_case_{i+1}"
            case_description = test_case.get('description', '')
            payloads = test_case.get('payloads', [])

            code += f'''
    def {method_name}(self):
        """
        {case_description}
        """
        print(f"    [+] Testing: {case_description}")

        payloads = {json.dumps(payloads, indent=8)}

        for payload in payloads:
            # Test each payload variation
            self.test_payload(payload)

    def test_payload(self, payload):
        """Test individual payload against target endpoints"""
        target_endpoints = {json.dumps([ep.get('url', '') for ep in target_endpoints], indent=8)}

        for endpoint_url in target_endpoints:
            if not endpoint_url:
                continue

            try:
                # Try POST request first
                response = self.session.post(
                    f"{{self.base_url}}{{endpoint_url}}",
                    json=payload,
                    headers={{'Content-Type': 'application/json'}}
                )

                # Check for vulnerability indicators
                if self.is_vulnerable_response(response):
                    self.vulnerabilities_found.append({{
                        'endpoint': endpoint_url,
                        'payload': payload,
                        'response_status': response.status_code,
                        'response_data': response.text[:200]
                    }})
                    print(f"        [!] POTENTIAL VULNERABILITY at {{endpoint_url}}")

            except Exception as e:
                print(f"        [-] Error testing {{endpoint_url}}: {{e}}")

    def is_vulnerable_response(self, response):
        """Check if response indicates vulnerability"""
        # Check for successful unauthorized access
        if response.status_code == 200:
            return True

        # Check for information disclosure
        if response.status_code == 500:
            if 'error' in response.text.lower() or 'exception' in response.text.lower():
                return True

        return False

    def generate_report(self):
        """Generate test report"""
        print(f"\\n{'='*50}")
        print(f"Test Report: {test_name}")
        print(f"{'='*50}")

        if self.vulnerabilities_found:
            print(f"[!] VULNERABILITIES FOUND: {{len(self.vulnerabilities_found)}}")
            for i, vuln in enumerate(self.vulnerabilities_found, 1):
                print(f"\\n{{i}}. Endpoint: {{vuln['endpoint']}}")
                print(f"   Payload: {{vuln['payload']}}")
                print(f"   Status: {{vuln['response_status']}}")
        else:
            print("[+] No vulnerabilities detected")

def main():
    """Test execution"""
    if len(sys.argv) < 2:
        print(f"Usage: python {{sys.argv[0]}} <base_url>")
        sys.exit(1)

    base_url = sys.argv[1]
    test = {test_name.title().replace('_', '')}Test(base_url)

    # Run all test cases
    test_case_methods = [method for method in dir(test) if method.startswith('test_case_')]
    for method_name in test_case_methods:
        getattr(test, method_name)()

    # Generate report
    test.generate_report()

if __name__ == "__main__":
    main()
'''

        return code


def main():
    """CLI interface for agent use"""
    if len(sys.argv) < 3:
        print("Usage: python generate_context_tests.py <app_structure_json> <output_file>", file=sys.stderr)
        print("Output: Generated tests to specified file", file=sys.stderr)
        sys.exit(1)

    structure_file = sys.argv[1]
    output_file = sys.argv[2]

    try:
        with open(structure_file, 'r') as f:
            app_structure = json.load(f)
    except Exception as e:
        print(f"Error reading app structure file: {e}", file=sys.stderr)
        sys.exit(1)

    generator = ContextAwareTestGenerator()
    generated_tests = generator.generate_tests_from_structure(app_structure)

    # Save to output file
    try:
        with open(output_file, 'w') as f:
            json.dump(generated_tests, f, indent=2)
        print(f"Generated tests saved to {output_file}", file=sys.stderr)

        # Print summary
        print(f"[+] Generated {len(generated_tests['test_scenarios'])} test scenarios", file=sys.stderr)
        print(f"[+] High priority tests: {len([s for s in generated_tests['test_scenarios'] if s.get('risk_level') == 'HIGH'])}", file=sys.stderr)
        print(f"[+] Target vulnerabilities: {', '.join(generated_tests['targeted_vulnerabilities'])}", file=sys.stderr)

    except Exception as e:
        print(f"Error saving generated tests: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()