#!/usr/bin/env python3
"""
Agent tool: Discover application structure without source access
Returns structured JSON for agent consumption
"""

import json
import sys
import urllib.request
import urllib.parse
import ssl
from urllib.error import URLError
from typing import Dict, List, Any
import re

class ApplicationStructureDiscovery:
    """
    Discovers API structure, data models, and business logic patterns
    Designed for agent consumption (JSON output, no prompts)
    """

    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')
        self.discovered_endpoints = []
        self.api_schema = None
        self.session_context = self._create_ssl_context()

    def _create_ssl_context(self):
        """Create SSL context for HTTPS requests"""
        ctx = ssl.create_default_context()
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE
        return ctx

    def _make_request(self, url: str) -> Dict[str, Any]:
        """Make HTTP request and return structured response"""
        try:
            req = urllib.request.Request(url)
            req.add_header('User-Agent', 'Agent-Discovery-Tool/1.0')
            req.add_header('Accept', 'application/json,text/html,*/*')

            with urllib.request.urlopen(req, context=self.session_context, timeout=10) as response:
                content = response.read().decode('utf-8', errors='ignore')

                return {
                    'status': response.status,
                    'headers': dict(response.headers),
                    'content': content,
                    'content_type': response.headers.get('content-type', ''),
                    'url': url
                }
        except Exception as e:
            return {
                'error': str(e),
                'url': url,
                'status': None
            }

    def discover_api_documentation(self) -> Dict[str, Any]:
        """Discover API documentation and schemas"""
        doc_endpoints = [
            '/docs', '/openapi.json', '/swagger.json', '/api/docs',
            '/api/docs.json', '/swagger-ui', '/redoc'
        ]

        discovered_docs = {}

        for doc_path in doc_endpoints:
            url = f"{self.base_url}{doc_path}"
            response = self._make_request(url)

            if response.get('status') == 200:
                if 'json' in response['content_type']:
                    try:
                        schema = json.loads(response['content'])
                        discovered_docs[doc_path] = {
                            'type': 'openapi_schema',
                            'schema': self._parse_openapi_schema(schema)
                        }
                    except json.JSONDecodeError:
                        continue
                else:
                    discovered_docs[doc_path] = {
                        'type': 'html_documentation',
                        'endpoints': self._extract_endpoints_from_html(response['content'])
                    }

        return discovered_docs

    def _parse_openapi_schema(self, schema: Dict[str, Any]) -> Dict[str, Any]:
        """Parse OpenAPI schema to extract structure"""
        if 'openapi' not in schema and 'swagger' not in schema:
            return {}

        parsed = {
            'version': schema.get('openapi', schema.get('swagger', 'unknown')),
            'endpoints': [],
            'data_models': [],
            'security_schemes': []
        }

        # Extract endpoints
        paths = schema.get('paths', {})
        for path, path_item in paths.items():
            for method, operation in path_item.items():
                if method.upper() in ['GET', 'POST', 'PUT', 'DELETE', 'PATCH']:
                    endpoint_info = {
                        'path': path,
                        'method': method.upper(),
                        'operation_id': operation.get('operationId'),
                        'summary': operation.get('summary'),
                        'parameters': operation.get('parameters', []),
                        'request_body': operation.get('requestBody', {}),
                        'responses': operation.get('responses', {}),
                        'tags': operation.get('tags', [])
                    }
                    parsed['endpoints'].append(endpoint_info)

        # Extract data models (schemas)
        components = schema.get('components', {})
        schemas = components.get('schemas', {})
        for model_name, model_def in schemas.items():
            parsed['data_models'].append({
                'name': model_name,
                'type': model_def.get('type', 'object'),
                'properties': model_def.get('properties', {}),
                'required': model_def.get('required', [])
            })

        # Extract security schemes
        security_schemes = components.get('securitySchemes', {})
        for scheme_name, scheme_def in security_schemes.items():
            parsed['security_schemes'].append({
                'name': scheme_name,
                'type': scheme_def.get('type'),
                'scheme': scheme_def.get('scheme')
            })

        return parsed

    def _extract_endpoints_from_html(self, html_content: str) -> List[str]:
        """Extract endpoint patterns from HTML documentation"""
        endpoints = []

        # Common patterns in API documentation
        patterns = [
            r'["\'](/api/[^"\']+)["\']',
            r'["\'](/v\d+/[^"\']+)["\']',
            r'(GET|POST|PUT|DELETE|PATCH)\s+(/[^\s\n]+)',
            r'endpoint:\s*["\']([^"\']+)["\']',
        ]

        for pattern in patterns:
            matches = re.findall(pattern, html_content, re.IGNORECASE)
            for match in matches:
                if isinstance(match, tuple):
                    endpoints.extend(match)
                else:
                    endpoints.append(match)

        return list(set(endpoints))  # Remove duplicates

    def discover_common_endpoints(self) -> List[Dict[str, Any]]:
        """Discover common API endpoints through intelligent probing"""
        common_patterns = [
            # REST API patterns
            '/api/v1/', '/api/', '/v1/', '/rest/',
            # Common resources
            '/users', '/auth', '/login', '/register', '/profile',
            '/posts', '/comments', '/files', '/upload',
            '/admin', '/config', '/settings', '/status'
        ]

        discovered = []

        for pattern in common_patterns:
            # Try both the pattern and common HTTP methods
            test_urls = [
                f"{self.base_url}{pattern}",
                f"{self.base_url}{pattern}/",
                f"{self.base_url}{pattern}/list",
                f"{self.base_url}{pattern}/create"
            ]

            for url in test_urls:
                response = self._make_request(url)

                if response.get('status') and response['status'] < 500:
                    discovered.append({
                        'url': url,
                        'path': pattern,
                        'status': response['status'],
                        'content_type': response.get('content_type', ''),
                        'methods': self._detect_allowed_methods(url)
                    })

        return discovered

    def _detect_allowed_methods(self, url: str) -> List[str]:
        """Detect allowed HTTP methods for an endpoint"""
        methods = []

        # Try different HTTP methods (limited to avoid too many requests)
        for method in ['GET', 'POST', 'PUT', 'DELETE']:
            try:
                req = urllib.request.Request(url, method=method)
                req.add_header('User-Agent', 'Agent-Discovery-Tool/1.0')

                with urllib.request.urlopen(req, context=self.session_context, timeout=5) as response:
                    # If we don't get a 405 Method Not Allowed, the method might be allowed
                    if response.status != 405:
                        methods.append(method)
            except:
                pass

        return methods

    def infer_data_models(self, responses: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Infer data models from response patterns"""
        data_models = {}

        for response in responses:
            content = response.get('content', '')
            content_type = response.get('content_type', '')

            if 'json' in content_type.lower():
                try:
                    json_data = json.loads(content)
                    self._analyze_json_structure(json_data, response['url'], data_models)
                except json.JSONDecodeError:
                    continue

        return data_models

    def _analyze_json_structure(self, data: Any, source_url: str, models: Dict[str, Any]):
        """Analyze JSON structure to infer data models"""
        if isinstance(data, dict):
            for key, value in data.items():
                if key not in models:
                    models[key] = {
                        'type': type(value).__name__,
                        'sources': [],
                        'properties': {}
                    }

                models[key]['sources'].append(source_url)

                if isinstance(value, dict):
                    models[key]['properties'].update({
                        sub_key: type(sub_val).__name__
                        for sub_key, sub_val in value.items()
                    })
                elif isinstance(value, list) and value:
                    if isinstance(value[0], dict):
                        models[key]['item_type'] = 'object'
                        models[key]['item_properties'] = {
                            sub_key: type(sub_val).__name__
                            for sub_key, sub_val in value[0].items()
                        }

        elif isinstance(data, list) and data:
            # Analyze array items
            if isinstance(data[0], dict):
                self._analyze_json_structure(data[0], source_url, models)

    def identify_business_entities(self, endpoints: List[Dict[str, Any]],
                                 data_models: Dict[str, Any]) -> List[str]:
        """Identify likely business entities based on patterns"""
        entities = []

        # Look for entity patterns in endpoints
        entity_patterns = [
            r'/users?', r'/posts?', r'/products?', r'/orders?', r'/accounts?',
            r'/profiles?', r'/teams?', r'/projects?', r'/tasks?', r'/comments?',
            r'/files?', r'/messages?', r'/notifications?', r'/settings?'
        ]

        all_paths = ' '.join([ep.get('path', '') + ep.get('url', '') for ep in endpoints])

        for pattern in entity_patterns:
            if re.search(pattern, all_paths, re.IGNORECASE):
                entity = pattern.strip(r'/?')
                if entity not in entities:
                    entities.append(entity)

        # Also look at data model names
        for model_name in data_models.keys():
            if any(common in model_name.lower() for common in ['user', 'post', 'product', 'order']):
                if model_name not in entities:
                    entities.append(model_name)

        return entities

    def detect_authentication_patterns(self, endpoints: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Detect authentication and authorization patterns"""
        auth_patterns = {
            'login_endpoints': [],
            'registration_endpoints': [],
            'session_management': [],
            'token_based': False,
            'cookie_based': False,
            'api_key_auth': False
        }

        auth_paths = {
            'login': ['/login', '/auth/login', '/signin', '/auth/signin'],
            'register': ['/register', '/signup', '/auth/register', '/auth/signup'],
            'logout': ['/logout', '/auth/logout', '/signout'],
            'token': ['/token', '/auth/token', '/oauth/token'],
            'refresh': ['/refresh', '/auth/refresh', '/token/refresh']
        }

        for endpoint in endpoints:
            path = endpoint.get('path', '')
            url = endpoint.get('url', '')

            for auth_type, auth_paths_list in auth_paths.items():
                if any(auth_path in path or auth_path in url for auth_path in auth_paths_list):
                    if auth_type == 'login':
                        auth_patterns['login_endpoints'].append(endpoint)
                    elif auth_type == 'register':
                        auth_patterns['registration_endpoints'].append(endpoint)
                    elif auth_type in ['logout', 'token', 'refresh']:
                        auth_patterns['session_management'].append(endpoint)

        # Check for API key patterns
        for endpoint in endpoints:
            headers = endpoint.get('headers', {})
            if any(key.lower() in ['authorization', 'x-api-key', 'api-key'] for key in headers.keys()):
                auth_patterns['api_key_auth'] = True
                break

        return auth_patterns

    def complete_discovery(self) -> Dict[str, Any]:
        """Perform complete application structure discovery"""
        print(f"[*] Discovering structure for {self.base_url}", file=sys.stderr)

        # Step 1: Discover API documentation
        print("[*] Looking for API documentation...", file=sys.stderr)
        api_docs = self.discover_api_documentation()

        # Step 2: Discover common endpoints
        print("[*] Probing common endpoints...", file=sys.stderr)
        common_endpoints = self.discover_common_endpoints()

        # Step 3: Collect response data for analysis
        print("[*] Analyzing response patterns...", file=sys.stderr)
        all_responses = [self._make_request(ep['url']) for ep in common_endpoints]
        all_responses.extend([resp for doc in api_docs.values() for resp in doc.get('responses', [])])

        # Step 4: Infer data models
        data_models = self.infer_data_models(all_responses)

        # Step 5: Identify business entities
        business_entities = self.identify_business_entities(common_endpoints, data_models)

        # Step 6: Detect authentication patterns
        auth_patterns = self.detect_authentication_patterns(common_endpoints)

        # Compile complete structure
        structure = {
            'base_url': self.base_url,
            'api_documentation': api_docs,
            'discovered_endpoints': common_endpoints,
            'data_models': data_models,
            'business_entities': business_entities,
            'authentication_patterns': auth_patterns,
            'discovery_summary': {
                'total_endpoints': len(common_endpoints),
                'data_models_found': len(data_models),
                'business_entities_found': len(business_entities),
                'api_documentation_found': len(api_docs)
            }
        }

        print(f"[+] Discovery complete: {structure['discovery_summary']}", file=sys.stderr)
        return structure


def main():
    """CLI interface for agent use"""
    if len(sys.argv) < 2:
        print("Usage: python discover_structure.py <base_url>", file=sys.stderr)
        print("Output: JSON structure to stdout", file=sys.stderr)
        sys.exit(1)

    base_url = sys.argv[1]
    discovery = ApplicationStructureDiscovery(base_url)
    structure = discovery.complete_discovery()

    # Output JSON to stdout for agent consumption
    print(json.dumps(structure, indent=2))


if __name__ == "__main__":
    main()